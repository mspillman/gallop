<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>gallop.intensities API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gallop.intensities</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import torch

# Not PEP8 compliant in most of the file but it&#39;s been formatted to try to be
# readable

@torch.jit.script
def get_symmetry_equivalent_points(frac_coords, nsamples_ones, affine_matrices):
    &#34;&#34;&#34;
    This code is a generic way to find all symmetry related positions in the
    unit cell from the affine-matrices of the space group. There are faster ways
    to generate intensities for some space groups, but these need to be coded
    separately. This function works in the generic case.

    Args:
        frac_coords (Tensor): Fractional coordinates for the asymmetric unit,
            with shape N_samples, Number of atoms in asymmetric unit, 3
        nsamples_ones (Tensor): A tensor filled with 1s, of shape:
            N_samples, Number of atoms in asymmetric unit, 1
        affine_matrices (Tensor): The affine matrices for the space group

    Returns:
        Tensor: The coordinates of all atoms in the unit cell. Tensor with shape
            N_samples, Number of atoms in unit cell, 3
    &#34;&#34;&#34;

    wxyz = torch.cat((frac_coords, nsamples_ones), dim=-1)
    frac_all = torch.einsum(&#34;bij,nkj-&gt;nbik&#34;,wxyz,affine_matrices)[:,:,:,:3]
    n_samples = frac_coords.shape[0]
    n_atoms = frac_coords.shape[1]*affine_matrices.shape[0]
    return frac_all.permute(1,0,2,3).reshape(n_samples,n_atoms,3)

@torch.jit.script
def intensities_from_full_cell_contents(frac_all, hkl, intensity_calc_prefix_fs,
    centrosymmetric):
    # type: (Tensor, Tensor, Tensor, bool) -&gt; Tensor
    &#34;&#34;&#34;
    Fall back generic method for intensity calculation if the space group is not
    included in calculate_intensities

    Args:
        frac_all (Tensor): Coordinates of all atoms in the unit cell
        hkl (Tensor): Miller indices
        intensity_calc_prefix_fs (Tensor): atomic scattering factors etc
        centrosymmetric (bool): True if space group is centrosymmetric

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    pi = 3.141592653589793
    hxkylz = 2. * pi * torch.einsum(&#34;ji,klj-&gt;kil&#34;, hkl, frac_all)
    Asqd = torch.einsum(&#34;ij,bij-&gt;bij&#34;,intensity_calc_prefix_fs,torch.cos(hxkylz)).sum(dim=2)**2
    if centrosymmetric:
        return Asqd
    else:
        Bsqd = torch.einsum(&#34;ij,bij-&gt;bij&#34;,intensity_calc_prefix_fs,torch.sin(hxkylz)).sum(dim=2)**2
        return Asqd + Bsqd

@torch.jit.script
def calculate_intensities(asymmetric_frac_coords, hkl, intensity_calc_prefix_fs,
        intensity_calc_prefix_fs_asymmetric, nsamples_ones, affine_matrices,
        centrosymmetric, space_group_number):
    # type: (Tensor, Tensor, Tensor, Tensor, Tensor, Tensor, bool, int) -&gt; Tensor
    &#34;&#34;&#34;
    Calculate the intensities for a set of Miller indices and atomic fractional
    coordinates. For some space groups, an equation taken from the International
    Tables of Crystallography has been used to allow the structure factors to be
    determined directly from the contents of the asymmetric unit.
    If this equation has not been added to the code, then the fall-back method
    is to generate the equivalent positions within the unit cell, and then
    determine the structure factors using the general P1 equation (or P-1 if
    centrosymmetric). Note: equations taken from international tables may not
    be faster or use less memory than the fallback method - testing is advised!

    Args:
        asymmetric_frac_coords (Tensor): The fractional coordinates of the atoms
            in the asymmetric unit
        hkl (Tensor): The hkl Miller indices of the observed reflections
        intensity_calc_prefix_fs (Tensor): The atomic scattering factors,
            occupancies and DW-factors of all atoms in the unit cell.
            Only used in fallback method, generated with a Structure object.
        intensity_calc_prefix_fs_asymmetric (Tensor): The atomic scattering
            factors, occupancies and DW-factors of atoms in the asymmetric unit.
            Generated with a Structure object.
        nsamples_ones (Tensor): a tensor of ones, with the
            shape(nsamples, natoms, 1). Only used in fallback method
        affine_matrices (Tensor): Tensor of affine matrices obtained from
            pymatgen. Only used in fallback method
        centrosymmetric (bool): True if the space group is centrosymmetric
            else False
        space_group_number (integer): The space group number for the current
            crystal

    Returns:
        intensities: A tensor of shape (n_samples, n_reflections) containing
                    the calculated intensities for all hkl&#39;s.
    &#34;&#34;&#34;
    pi = 3.141592653589793
    peaks = hkl.shape[1]
    if space_group_number == 1:
        # P1
        hxkylz = 2 * pi * torch.einsum(&#34;ji,klj-&gt;kil&#34;, hkl, asymmetric_frac_coords)
        Asqd = torch.einsum(&#34;ij,bij-&gt;bij&#34;,intensity_calc_prefix_fs_asymmetric,torch.cos(hxkylz)).sum(dim=2)**2
        Bsqd = torch.einsum(&#34;ij,bij-&gt;bij&#34;,intensity_calc_prefix_fs_asymmetric,torch.sin(hxkylz)).sum(dim=2)**2
        # (a + ib) * (a - ib) = a^2 + b^2
        intensities = Asqd + Bsqd

    elif space_group_number == 2:
        # P-1
        hxkylz = 2 * pi * torch.einsum(&#34;ji,klj-&gt;kil&#34;, hkl, asymmetric_frac_coords)
        A = 2 * torch.cos(hxkylz)
        intensities = torch.einsum(&#34;ij,bij-&gt;bij&#34;,intensity_calc_prefix_fs_asymmetric,A).sum(dim=2)**2

    elif space_group_number == 3:
        # P2
        hl = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[0], asymmetric_frac_coords[:,:,0])
                        + torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[2], asymmetric_frac_coords[:,:,2]))
        ky = 2 * pi * torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[1], asymmetric_frac_coords[:,:,1])

        chl = torch.cos(hl)
        cky = torch.cos(ky)
        sky = torch.sin(ky)

        A = 2 * chl * cky
        B = 2 * chl * sky
        Asqd = torch.einsum(&#34;ij,bij-&gt;bij&#34;,intensity_calc_prefix_fs_asymmetric,A).sum(dim=2)**2
        Bsqd = torch.einsum(&#34;ij,bij-&gt;bij&#34;,intensity_calc_prefix_fs_asymmetric,B).sum(dim=2)**2
        intensities = Asqd + Bsqd

    elif space_group_number == 4:
        # P21
        hl = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[0], asymmetric_frac_coords[:,:,0])
                        + torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[2], asymmetric_frac_coords[:,:,2])
                        + hkl[1].view(1,peaks,1)/4)
        ky = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[1], asymmetric_frac_coords[:,:,1])
                        - hkl[1].view(1,peaks,1)/4)

        chl = torch.cos(hl)
        cky = torch.cos(ky)
        sky = torch.sin(ky)

        A = 2 * chl * cky
        B = 2 * chl * sky

        Asqd = torch.einsum(&#34;ij,bij-&gt;bij&#34;,intensity_calc_prefix_fs_asymmetric,A).sum(dim=2)**2
        Bsqd = torch.einsum(&#34;ij,bij-&gt;bij&#34;,intensity_calc_prefix_fs_asymmetric,B).sum(dim=2)**2
        intensities = Asqd + Bsqd

    elif space_group_number == 5:
        # C2
        # This expression is simpler and quicker than the style used
        # in the other space groups. For reference, it would be:
        # A = 4 * cos(2pi (h+k/4))*cos(2pi(hx+lz))*cos(2piky)
        # B = 4 * cos(2pi (h+k/4))*cos(2pi(hx+lz))*sin(2piky)
        # This would require a minimum of 3 x trig functions to determine
        # whereas the following only requires 2.
        chl = torch.cos(2.*pi*(torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[0], asymmetric_frac_coords[:,:,0])
                                + torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[2], asymmetric_frac_coords[:,:,2])))
        ky = 2 * pi * torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[1], asymmetric_frac_coords[:,:,1])

        A = 4 * chl * torch.cos(ky)
        B = 4 * chl * torch.sin(ky)

        Asqd = torch.einsum(&#34;ij,bij-&gt;bij&#34;,intensity_calc_prefix_fs_asymmetric,A).sum(dim=2)**2
        Bsqd = torch.einsum(&#34;ij,bij-&gt;bij&#34;,intensity_calc_prefix_fs_asymmetric,B).sum(dim=2)**2
        intensities = Asqd + Bsqd

    elif space_group_number == 7:
        # Pc
        hl = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[0], asymmetric_frac_coords[:,:,0])
                        + torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[2], asymmetric_frac_coords[:,:,2])
                        + hkl[2].view(1,peaks,1)/4)
        ky = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[1], asymmetric_frac_coords[:,:,1])
                        - hkl[2].view(1,peaks,1)/4)

        chl = torch.cos(hl)
        shl = torch.sin(hl)
        cky = torch.cos(ky)
        A = 2 * chl * cky
        B = 2 * shl * cky

        Asqd = torch.einsum(&#34;ij,bij-&gt;bij&#34;,intensity_calc_prefix_fs_asymmetric,A).sum(dim=2)**2
        Bsqd = torch.einsum(&#34;ij,bij-&gt;bij&#34;,intensity_calc_prefix_fs_asymmetric,B).sum(dim=2)**2
        intensities = Asqd + Bsqd

    elif space_group_number == 9:
        # Cc
        hl = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[0], asymmetric_frac_coords[:,:,0])
                        + torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[2], asymmetric_frac_coords[:,:,2])
                        + hkl[2].view(1,peaks,1)/4)
        ky = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[1], asymmetric_frac_coords[:,:,1])
                        - hkl[2].view(1,peaks,1)/4)
        hk = (2 * pi * (hkl[0] + hkl[1])/4).view(1,peaks,1)

        chl = torch.cos(hl)
        shl = torch.sin(hl)
        cky = torch.cos(ky)
        c_sqd_hk = torch.cos(hk)**2
        A = 4 * c_sqd_hk * chl * cky
        B = 4 * c_sqd_hk * shl * cky

        Asqd = torch.einsum(&#34;ij,bij-&gt;bij&#34;,intensity_calc_prefix_fs_asymmetric,A).sum(dim=2)**2
        Bsqd = torch.einsum(&#34;ij,bij-&gt;bij&#34;,intensity_calc_prefix_fs_asymmetric,B).sum(dim=2)**2
        intensities = Asqd + Bsqd

    elif space_group_number == 11:
        # P21/m
        hl = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[0], asymmetric_frac_coords[:,:,0])
                        + torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[2], asymmetric_frac_coords[:,:,2])
                        + hkl[1].view(1,peaks,1)/4)
        ky = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[1], asymmetric_frac_coords[:,:,1])
                        - hkl[1].view(1,peaks,1)/4)

        A = 4 * torch.cos(hl) * torch.cos(ky)
        intensities = torch.einsum(&#34;ij,bij-&gt;bij&#34;,intensity_calc_prefix_fs_asymmetric,A).sum(dim=2)**2

    elif space_group_number == 12:
        # C2/m
        hl = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[0], asymmetric_frac_coords[:,:,0])
                        + torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[2], asymmetric_frac_coords[:,:,2]))
        ky = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[1], asymmetric_frac_coords[:,:,1]))
        hk = (2 * pi * (hkl[0] + hkl[1])/4).view(1,peaks,1)
        c_sqd_hk = torch.cos(hk)**2
        A = 8 * c_sqd_hk * torch.cos(hl) * torch.cos(ky)
        intensities = torch.einsum(&#34;ij,bij-&gt;bij&#34;,intensity_calc_prefix_fs_asymmetric,A).sum(dim=2)**2

    elif space_group_number == 13:
        # P2/c
        hl = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[0], asymmetric_frac_coords[:,:,0])
                        + torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[2], asymmetric_frac_coords[:,:,2])
                        + hkl[2].view(1,peaks,1)/4)
        ky = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[1], asymmetric_frac_coords[:,:,1])
                        - hkl[2].view(1,peaks,1)/4)
        A = 4 * torch.cos(hl) * torch.cos(ky)
        intensities = torch.einsum(&#34;ij,bij-&gt;bij&#34;,intensity_calc_prefix_fs_asymmetric,A).sum(dim=2)**2

    elif space_group_number == 14:
        # P21/c
        hl = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[0], asymmetric_frac_coords[:,:,0])
                        + torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[2], asymmetric_frac_coords[:,:,2])
                        + (hkl[1] + hkl[2]).view(1,peaks,1)/4)
        ky = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[1], asymmetric_frac_coords[:,:,1])
                        - (hkl[1] + hkl[2]).view(1,peaks,1)/4)
        A = 4 * torch.cos(hl) * torch.cos(ky)
        intensities = torch.einsum(&#34;ij,bij-&gt;bij&#34;,intensity_calc_prefix_fs_asymmetric,A).sum(dim=2)**2

    elif space_group_number == 15:
        # C2/c
        # The initial term involving only h and k could be calculated in advance.
        hl = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[0], asymmetric_frac_coords[:,:,0])
                        + torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[2], asymmetric_frac_coords[:,:,2])
                        + hkl[2].view(1,peaks,1)/4)
        ky = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[1], asymmetric_frac_coords[:,:,1])
                        - hkl[2].view(1,peaks,1)/4)

        A = 8 * (((torch.cos((2 * pi * (hkl[0] + hkl[1]))/4))**2).view(1,peaks,1)
                    * torch.cos(hl) * torch.cos(ky))

        intensities = torch.einsum(&#34;ij,bij-&gt;bij&#34;,intensity_calc_prefix_fs_asymmetric,A).sum(dim=2)**2

    elif space_group_number == 18:
        # P21212
        hx = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[0], asymmetric_frac_coords[:,:,0])
                        + (hkl[0] + hkl[1]).view(1,peaks,1)/4)
        ky = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[1], asymmetric_frac_coords[:,:,1])
                        - (hkl[0] + hkl[1]).view(1,peaks,1)/4)
        lz = 2 * pi * torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[2], asymmetric_frac_coords[:,:,2])

        chx = torch.cos(hx)
        cky = torch.cos(ky)
        clz = torch.cos(lz)

        shx = torch.sin(hx)
        sky = torch.sin(ky)
        slz = torch.sin(lz)

        A =  4 * chx * cky * clz
        B = -4 * shx * sky * slz

        Asqd = torch.einsum(&#34;ij,bij-&gt;bij&#34;,intensity_calc_prefix_fs_asymmetric,A).sum(dim=2)**2
        Bsqd = torch.einsum(&#34;ij,bij-&gt;bij&#34;,intensity_calc_prefix_fs_asymmetric,B).sum(dim=2)**2
        intensities = Asqd + Bsqd

    elif space_group_number == 19:
        # P212121
        hx = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[0], asymmetric_frac_coords[:,:,0])
                        - (hkl[0] - hkl[1]).view(1,peaks,1)/4)
        ky = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[1], asymmetric_frac_coords[:,:,1])
                        - (hkl[1] - hkl[2]).view(1,peaks,1)/4)
        lz = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[2], asymmetric_frac_coords[:,:,2])
                        - (hkl[2] - hkl[0]).view(1,peaks,1)/4)

        chx = torch.cos(hx)
        cky = torch.cos(ky)
        clz = torch.cos(lz)

        shx = torch.sin(hx)
        sky = torch.sin(ky)
        slz = torch.sin(lz)

        A =  4 * chx * cky * clz
        B = -4 * shx * sky * slz

        Asqd = torch.einsum(&#34;ij,bij-&gt;bij&#34;,intensity_calc_prefix_fs_asymmetric,A).sum(dim=2)**2
        Bsqd = torch.einsum(&#34;ij,bij-&gt;bij&#34;,intensity_calc_prefix_fs_asymmetric,B).sum(dim=2)**2
        intensities = Asqd + Bsqd

    elif space_group_number == 29:
        # Pca21
        hx = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[0], asymmetric_frac_coords[:,:,0])
                        - (hkl[0] + hkl[2]).view(1,peaks,1)/4)
        ky = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[1], asymmetric_frac_coords[:,:,1])
                        + (hkl[0]).view(1,peaks,1)/4)
        lz = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[2], asymmetric_frac_coords[:,:,2])
                        + (hkl[2]).view(1,peaks,1)/4)
        chx = torch.cos(hx)
        cky = torch.cos(ky)
        clz = torch.cos(lz)
        slz = torch.sin(lz)

        A = 4 * chx * cky * clz
        B = 4 * chx * cky * slz

        Asqd = torch.einsum(&#34;ij,bij-&gt;bij&#34;,intensity_calc_prefix_fs_asymmetric,A).sum(dim=2)**2
        Bsqd = torch.einsum(&#34;ij,bij-&gt;bij&#34;,intensity_calc_prefix_fs_asymmetric,B).sum(dim=2)**2
        intensities = Asqd + Bsqd

    elif space_group_number == 33:
        # Pna21
        hx = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[0], asymmetric_frac_coords[:,:,0])
                        - (hkl[0] + hkl[1] + hkl[2]).view(1,peaks,1)/4)
        ky = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[1], asymmetric_frac_coords[:,:,1])
                        + (hkl[0] + hkl[1]).view(1,peaks,1)/4)
        lz = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[2], asymmetric_frac_coords[:,:,2])
                        + (hkl[2]).view(1,peaks,1)/4)
        chx = torch.cos(hx)
        cky = torch.cos(ky)
        clz = torch.cos(lz)
        slz = torch.sin(lz)

        A = 4 * chx * cky * clz
        B = 4 * chx * cky * slz

        Asqd = torch.einsum(&#34;ij,bij-&gt;bij&#34;,intensity_calc_prefix_fs_asymmetric,A).sum(dim=2)**2
        Bsqd = torch.einsum(&#34;ij,bij-&gt;bij&#34;,intensity_calc_prefix_fs_asymmetric,B).sum(dim=2)**2
        intensities = Asqd + Bsqd

    elif space_group_number == 60:
        # Pbcn
        hx = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[0], asymmetric_frac_coords[:,:,0])
                        + (hkl[0] + hkl[1]).view(1,peaks,1)/4)
        ky = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[1], asymmetric_frac_coords[:,:,1])
                        + (hkl[2]).view(1,peaks,1)/4)
        lz = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[2], asymmetric_frac_coords[:,:,2])
                        - (hkl[0] + hkl[1] + hkl[2]).view(1,peaks,1)/4)
        chx = torch.cos(hx)
        cky = torch.cos(ky)
        clz = torch.cos(lz)

        A = 8 * chx * cky * clz
        intensities = torch.einsum(&#34;ij,bij-&gt;bij&#34;,intensity_calc_prefix_fs_asymmetric,A).sum(dim=2)**2

    elif space_group_number == 61:
        # Pbca
        hx = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[0], asymmetric_frac_coords[:,:,0])
                        - (hkl[0] - hkl[1]).view(1,peaks,1)/4)
        ky = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[1], asymmetric_frac_coords[:,:,1])
                        - (hkl[1] - hkl[2]).view(1,peaks,1)/4)
        lz = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[2], asymmetric_frac_coords[:,:,2])
                        - (hkl[2] - hkl[0]).view(1,peaks,1)/4)
        chx = torch.cos(hx)
        cky = torch.cos(ky)
        clz = torch.cos(lz)

        A = 8 * chx * cky * clz
        intensities = torch.einsum(&#34;ij,bij-&gt;bij&#34;,intensity_calc_prefix_fs_asymmetric,A).sum(dim=2)**2

    elif space_group_number == 62:
        # Pnma
        hx = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[0], asymmetric_frac_coords[:,:,0])
                        - (hkl[0] + hkl[1] + hkl[2]).view(1,peaks,1)/4)
        ky = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[1], asymmetric_frac_coords[:,:,1])
                        + (hkl[1]).view(1,peaks,1)/4)
        lz = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[2], asymmetric_frac_coords[:,:,2])
                        + (hkl[0] + hkl[2]).view(1,peaks,1)/4)
        chx = torch.cos(hx)
        cky = torch.cos(ky)
        clz = torch.cos(lz)

        A = 8 * chx * cky * clz
        intensities = torch.einsum(&#34;ij,bij-&gt;bij&#34;,intensity_calc_prefix_fs_asymmetric,A).sum(dim=2)**2

    elif space_group_number == 88:
        # I41/a
        chkl  = torch.cos(2*pi*(hkl[0] + hkl[1] + hkl[2]).view(1,peaks,1)/4)
        chxky = torch.cos(2*pi*(torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[0], asymmetric_frac_coords[:,:,0])
                                + torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[1], asymmetric_frac_coords[:,:,1])
                                - (hkl[1]).view(1,peaks,1)/4))
        clz_k = torch.cos(2*pi*(torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[2], asymmetric_frac_coords[:,:,2])
                                + (hkl[1]).view(1,peaks,1)/4))
        chykx = torch.cos(2*pi*(torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[0], asymmetric_frac_coords[:,:,1])
                                - torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[1], asymmetric_frac_coords[:,:,0])
                                - (hkl[0]).view(1,peaks,1)/4))
        clz_h = torch.cos(2*pi*(torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[2], asymmetric_frac_coords[:,:,2])
                                + (hkl[0]).view(1,peaks,1)/4))

        A = 8 * chkl * ((chkl * chxky * clz_k) + (chykx * clz_h))
        intensities = torch.einsum(&#34;ij,bij-&gt;bij&#34;,intensity_calc_prefix_fs_asymmetric,A).sum(dim=2)**2

    elif space_group_number == 148:
        # R-3
        # Using Rhombohedral coordinates
        hxkylz = 2 * pi * torch.einsum(&#34;ji,klj-&gt;kil&#34;, hkl, asymmetric_frac_coords)
        kxlyhz = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[1], asymmetric_frac_coords[:,:,0])
                            + torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[2], asymmetric_frac_coords[:,:,1])
                            + torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[0], asymmetric_frac_coords[:,:,2]))
        lxhykz = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[2], asymmetric_frac_coords[:,:,0])
                            + torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[0], asymmetric_frac_coords[:,:,1])
                            + torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[1], asymmetric_frac_coords[:,:,2]))

        chx = torch.cos(hxkylz)
        ckx = torch.cos(kxlyhz)
        clx = torch.cos(lxhykz)

        A = 2 * (chx + ckx + clx)

        # Using hexagonal coordinates, the equivalent equations would be as below
        #i = -1*(hkl[0] + hkl[1])
        #chkl   = torch.cos(2 * pi * (hkl[1] + hkl[2] - hkl[0]).view(1,peaks,1)/3)
        #hxkylz = 2 * pi * torch.einsum(&#34;ji,klj-&gt;kil&#34;, hkl, asymmetric_frac_coords)
        #kxiyhz = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[1], asymmetric_frac_coords[:,:,0])
        #                   + torch.einsum(&#34;i,jk-&gt;jik&#34;, i, asymmetric_frac_coords[:,:,1])
        #                   + torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[2], asymmetric_frac_coords[:,:,2]))
        #ixhylz = 2 * pi * (torch.einsum(&#34;i,jk-&gt;jik&#34;, i, asymmetric_frac_coords[:,:,0])
        #                   + torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[0], asymmetric_frac_coords[:,:,1])
        #                   + torch.einsum(&#34;i,jk-&gt;jik&#34;, hkl[2], asymmetric_frac_coords[:,:,2]))
        #chx = torch.cos(hxkylz)
        #ckx = torch.cos(kxiyhz)
        #cix = torch.cos(ixhylz)#
        #A = 2 * (1 + 2*chkl) * chx * ckx * cix

        intensities = torch.einsum(&#34;ij,bij-&gt;bij&#34;,intensity_calc_prefix_fs_asymmetric,A).sum(dim=2)**2

    else:
        # Use a fall-back method to generate all equivalent positions in the unit cell
        frac_all = get_symmetry_equivalent_points(asymmetric_frac_coords,
                                    nsamples_ones, affine_matrices)
        # And then the P1 structure factor equation to obtain the intensities.
        intensities = intensities_from_full_cell_contents(frac_all, hkl,
                                    intensity_calc_prefix_fs, centrosymmetric)

    return intensities</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gallop" href="index.html">gallop</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>