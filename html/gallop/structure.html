<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>gallop.structure API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gallop.structure</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import json
import os
import numpy as np
import pymatgen as pmg
from pymatgen.symmetry import groups
import gallop.z_matrix as zm
import gallop.files as files

class Structure(object):
    &#34;&#34;&#34;
    The main class used in GALLOP to hold all of the information
    about a crystal structure that is needed for SDPD attempts.

    Before SDPD can be attempted, the following numpy arrays are
    needed:
        - hkl = Structure.hkl
        - intensities = Structure.intensities
        - inverse_covariance_matrix = structure.inverse_covariance_matrix
    As well as:
        - zmatrices populated with GALLOP Z_matrix objects all of
            the ZMs in the asymmetric unit
            Stored in Structure.zmatrices (list of Z-matrix objects)
        - Structure.lattice = pymatgen lattice
        - Structure.space_group = pymatgen space_group
        - Structure.sg_number = sg_number (integer)
        - Structure.centrosymmetric = centrosymmetric (bool)

    If using files generated by Pawley fitting the data with DASH, GSAS-II or
    TOPAS, helper functions are available to automate the population of
    the required arrays and parameters.

    &#34;&#34;&#34;
    def __init__(self, name=&#34;Gallop_structure&#34;, ignore_H_atoms=True,
                    absorb_H_Z_increase=False, absorb_H_occu_increase=False):
        &#34;&#34;&#34;
        Args:
            name (str, optional): The root name to be used for
                writing CIFs during SDPD attempts. Defaults to
                &#34;Gallop_structure&#34;.
            ignore_H_atoms (bool, optional): Ignore H-atoms during
                SDPD. Setting this to True, and
                absorb_H_occu_increase and absorb_H_Z_increase to
                False will simply ignore the presence of H atoms.
                Defaults to True.
            absorb_H_Z_increase (bool, optional): If ignore_H_atoms,
                offset the loss of electrons in unit cell by
                increasing the atomic number of the non-H atoms by
                the number of connected H atoms. Defaults to False.
            absorb_H_occu_increase (bool, optional): If ignore_H_atoms,
                offset the loss of electrons in the unit cell by
                increasing the occupancy of the non-H atoms by
                a factor of (1 + n_H_connected_expanded)/non_H(Z).
                Defaults to False.
        &#34;&#34;&#34;
        self.name = name
        self.ignore_H_atoms = ignore_H_atoms
        self.output_filename_root = name
        self.zmatrices = []
        self.absorb_H_Z_increase = absorb_H_Z_increase
        self.absorb_H_occu_increase = absorb_H_occu_increase

        self.original_sg_number = None
        self.total_dof_calculated = False
        self.sg_number = None
        self.wavelength = None
        self.hkl = None
        self.twotheta = []
        self.space_group = None
        self.lattice = None
        self.cif_frac_coords_no_H = None
        self.cif_species_no_H = None
        self.cif_frac_coords = None
        self.cif_species = None
        self.data_file = None
        self.dspacing = None
        self.data_resolution = None
        self.source = None
        self.centrosymmetric = None
        self.affine_matrices = None
        self.cif_dwfactors = None
        self.dwfactors_asymmetric = None
        self.dwfactors = None
        self.total_degrees_of_freedom = None
        self.total_external_degrees_of_freedom = None
        self.total_internal_degrees_of_freedom = None
        self.total_position_degrees_of_freedom = None
        self.total_rotation_degrees_of_freedom = None
        self.zm_torsions = None

    def __repr__(self):
        return self.name

    def to_json(self, return_json=True):
        &#34;&#34;&#34;
        Save a structure object to a JSON formatted string. Can then be used to
        instantiate a structure object from a string (or file)

        Args:
            return_json (bool, optional): If True, return a JSON formatted
                string, else return a dictionary. Default is True.

        Returns:
            dict or str: JSON-compatible dict or JSON formatted string
        &#34;&#34;&#34;
        dumpable = {}
        for k, v in self.__dict__.items():
            if k in [&#34;zmatrices&#34;, &#34;lattice&#34;, &#34;space_group&#34;]:
                if k == &#34;zmatrices&#34;:
                    dumpable[k] = [zm.to_json(return_json=return_json) for zm in v]
                elif k == &#34;lattice&#34;:
                    dumpable[k] = v.as_dict()
            else:
                if isinstance(v, np.ndarray):
                    dumpable[k] = [v.tolist(), True]
                elif isinstance(v, np.int32):
                    dumpable[k] = [int(v), False]
                else:
                    dumpable[k] = [v, False]
        if return_json:
            return json.dumps(dumpable)
        else:
            return dumpable

    def from_json(self, attributes, is_json=True):
        &#34;&#34;&#34;
        Load a structure object from JSON formatted string

        Args:
            attributes (str or dict): JSON formatted string of a structure
                                    produced by the to_json method
            is_json (bool, optional): Toggles reading dict directly or using a
                JSON formatted string. Default is True
        &#34;&#34;&#34;
        if is_json:
            attributes = json.loads(attributes)
        for k, v in attributes.items():
            if k in [&#34;zmatrices&#34;, &#34;lattice&#34;, &#34;space_group&#34;]:
                if k == &#34;zmatrices&#34;:
                    zmatrices = []
                    for zmstring in v:
                        zmat = zm.Z_matrix()
                        zmat.from_json(zmstring, is_json=is_json)
                        zmatrices.append(zmat)
                    setattr(self, k, zmatrices)
                elif k == &#34;lattice&#34;:
                    lattice = pmg.Lattice.from_dict(v)
                    setattr(self,k,lattice)
            else:
                if v[1]:
                    setattr(self, k, np.array(v[0]))
                else:
                    setattr(self, k, v[0])
        setattr(self, &#34;space_group&#34;,
                        groups.SpaceGroup.from_int_number(self.sg_number))

    def add_zmatrix(self, filename, verbose=True):
        &#34;&#34;&#34;
        Create and add a z-matrix object to the Structure

        Args:
            filename (str): filename of the Z-matrix
            verbose (bool, optional): Print out information. Defaults to True.
        &#34;&#34;&#34;
        self.zmatrices.append(zm.Z_matrix(filename))
        if verbose:
            print(&#34;Added Z-matrix with&#34;,self.zmatrices[-1])

    def get_resolution(self, twotheta, decimal_places=3):
        &#34;&#34;&#34;
        Calculate the d-spacing of a given twotheta value using Bragg&#39;s law

        Args:
            twotheta (float): The twotheta value of interest
            decimal_places (int, optional): Number of decimal_places to restrict
                the result to. Defaults to 3.

        Returns:
            float: the d-spacing of a twotheta value
        &#34;&#34;&#34;
        d = self.wavelength / (2*np.sin(np.deg2rad(twotheta/2)))
        return (np.around(d, decimal_places))

    def add_data(self, filename, source=&#34;DASH&#34;,
                percentage_cutoff=20):
        &#34;&#34;&#34;
        Add PXRD data to a Z-matrix

        Args:
            filename (str): filename of file from which to read the data
            source (str, optional): data source. Currently only &#34;DASH&#34; is
                accepted as an argument. More programs may be added in the
                future. Defaults to &#34;DASH&#34;.
            percentage_cutoff_hcv (int, optional): the minimum percentage
            correlation to be included in the inverse covariance
            matrix. Defaults to 20 to be comparable with DASH,
            however, this doesn&#39;t affect the speed of GALLOP so can
            be set as desired without impacting performance.
        &#34;&#34;&#34;
        self.data_file = filename
        if source.lower() == &#34;dash&#34;:
            data = files.get_data_from_DASH_sdi(filename,
                        percentage_cutoff_inv_cov=percentage_cutoff)
            for k, v in data.items():
                setattr(self, k, v)
            self.dspacing = self.get_resolution(self.twotheta)
            self.data_resolution = self.get_resolution(self.twotheta[-1])
            self.source = &#34;dash&#34;
        elif &#34;gsas&#34; in source.lower():
            data = files.get_data_from_GSAS_gpx(filename,
                            percentage_cutoff_inv_cov=percentage_cutoff)
            for k, v in data.items():
                setattr(self, k, v)
            self.data_resolution = self.dspacing[-1]
            self.source = &#34;gsas&#34;
        elif &#34;topas&#34; == source.lower():
            data = files.get_data_from_TOPAS_output(filename,
                            percentage_cutoff_inv_cov=percentage_cutoff)
            for k, v in data.items():
                setattr(self, k, v)
            self.source = &#34;topas&#34;
        else:
            print(&#34;This program is not yet supported.&#34;)
            print(&#34;Currently supported programs:&#34;)
            print(&#34; - DASH&#34;)
            print(&#34; - GSAS-II&#34;)
            print(&#34; - TOPAS&#34;)
        self.centrosymmetric = self.check_centre_of_symmetry()
        self.affine_matrices = self.get_affine_matrices()

    def check_centre_of_symmetry(self):
        &#34;&#34;&#34;
        Check if a structure is centrosymmetric

        Returns:
            bool: True if centrosymmetric
        &#34;&#34;&#34;
        laue = [&#34;-1&#34;, &#34;2/m&#34;, &#34;mmm&#34;, &#34;4/m&#34;, &#34;4/mmm&#34;,
                    &#34;-3&#34;, &#34;-3m&#34;, &#34;6/m&#34;, &#34;6/mmm&#34;, &#34;m-3&#34;, &#34;m-3m&#34;]
        return self.space_group.point_group in laue

    def get_affine_matrices(self):
        &#34;&#34;&#34;
        Get the affine matrices of the space group
        Used as a fall-back (generic) method for structure factor
        calculation.

        GALLOP Structure must have a pymatgen space_group assigned

        Returns:
            numpy array:    affine matrices for the space group
                            of shape (n,4,4) where n is the number
                            of equivalent positions for the space
                            group.
        &#34;&#34;&#34;
        affine_matrices = []
        for op in self.space_group.symmetry_ops:
            affine_matrices.append(op.affine_matrix)
        return np.array(affine_matrices)

    def generate_intensity_calculation_prefix(self,
                                            debye_waller_factors=None,
                                            just_asymmetric=False,
                                            from_cif=False):
        &#34;&#34;&#34;
        Much of this code is directly adapted from the PyMatGen code
        for PXRD pattern generation, which can be found here:
        https://pymatgen.org/pymatgen.analysis.diffraction.xrd.html
        A few modifications have been made. For example, ability to &#34;absorb&#34;
        H atoms by increasing the atomic number used to calculate
        atomic form factors, or increase the occupancy of the non-H
        atoms.

        If reading directly from a CIF then the atomic coordinates
        are used. If not reading from a CIF, then a dummy structure
        is created in order to extract the required information.
        This can either just be the atoms in the asymmetric unit,
        or the whole unit cell.
        &#34;&#34;&#34;
        if debye_waller_factors is None:
            debye_waller_factors = {}
        if len(self.zmatrices) == 0 and not from_cif:
            print(&#34;No Z-matrices have been added!&#34;)
        else:
            if not from_cif:
                all_atoms_coords = []
                all_atoms_elements = []
                all_atoms_n_H_connected = []
                for zmat in self.zmatrices:
                    if self.ignore_H_atoms:
                        all_atoms_coords.append(
                            zmat.initial_cartesian_no_H)
                        all_atoms_elements.append(
                            zmat.elements_no_H)
                        all_atoms_n_H_connected.append(
                            zmat.n_H_connected)
                    else:
                        all_atoms_coords.append(zmat.initial_cartesian)
                        all_atoms_elements.append(zmat.elements)

                all_atoms_coords = np.vstack(all_atoms_coords)
                all_atoms_elements = np.hstack(all_atoms_elements)
                if self.ignore_H_atoms:
                    all_atoms_n_H_connected = np.hstack(all_atoms_n_H_connected)
                else:
                    all_atoms_n_H_connected = np.array(all_atoms_n_H_connected)

                fractional_coords = np.dot(all_atoms_coords,
                                                        self.lattice.inv_matrix)
            else:
                if self.ignore_H_atoms:
                    fractional_coords = self.cif_frac_coords_no_H
                    all_atoms_elements = self.cif_species_no_H
                else:
                    fractional_coords = self.cif_frac_coords
                    all_atoms_elements = self.cif_species
                just_asymmetric = True

            if not just_asymmetric:
                # Apply symmetry of space group to locate all atoms
                # within the unit cell. This is a dummy structure,
                # and the purpose is only to extract the atomic
                # scattering parameters etc, which are independent
                # of position in the unit cell.
                species_expanded = []
                fractional_expanded = []
                n_H_connected_expanded = []
                xyzw = np.vstack((fractional_coords.T, np.ones((1,
                                    fractional_coords.shape[0]))))
                for am in self.affine_matrices:
                    expanded = np.array(np.dot(am, xyzw).T)
                    fractional_expanded.append(expanded[:,:3])
                    species_expanded.append(all_atoms_elements)
                    n_H_connected_expanded.append(all_atoms_n_H_connected)
                species_expanded = np.array(species_expanded).ravel()
                fractional_expanded = np.vstack(fractional_expanded)
                n_H_connected_expanded = np.hstack(n_H_connected_expanded)
            else:
                species_expanded = all_atoms_elements
                fractional_expanded = fractional_coords
                if not from_cif:
                    n_H_connected_expanded = all_atoms_n_H_connected

            with open(
                os.path.join(&#34;gallop&#34;,&#34;atomic_scattering_params.json&#34;)) as f:
                ATOMIC_SCATTERING_PARAMS = json.load(f)
            f.close()

            zs = []
            coeffs = []
            occus = []
            dwfactors = []
            atomic_numbers = {
                1 : &#34;H&#34;, 2 : &#34;He&#34;, 3 : &#34;Li&#34;, 4 : &#34;Be&#34;, 5 : &#34;B&#34;,
                6 : &#34;C&#34;, 7 : &#34;N&#34;, 8 : &#34;O&#34;, 9 : &#34;F&#34;, 10 : &#34;Ne&#34;,
                11 : &#34;Na&#34;, 12 : &#34;Mg&#34;, 13 : &#34;Al&#34;, 14 : &#34;Si&#34;, 15 : &#34;P&#34;,
                16 : &#34;S&#34;, 17 : &#34;Cl&#34;, 18 : &#34;Ar&#34;, 19 : &#34;K&#34;, 20 : &#34;Ca&#34;,
                21 : &#34;Sc&#34;, 22 : &#34;Ti&#34;, 23 : &#34;V&#34;, 24 : &#34;Cr&#34;, 25 : &#34;Mn&#34;,
                26 : &#34;Fe&#34;, 27 : &#34;Co&#34;, 28 : &#34;Ni&#34;, 29 : &#34;Cu&#34;,
                30 : &#34;Zn&#34;, 31 : &#34;Ga&#34;, 32 : &#34;Ge&#34;, 33 : &#34;As&#34;,
                34 : &#34;Se&#34;, 35 : &#34;Br&#34;, 36 : &#34;Kr&#34;, 37 : &#34;Rb&#34;,
                38 : &#34;Sr&#34;, 39 : &#34;Y&#34;, 40 : &#34;Zr&#34;, 41 : &#34;Nb&#34;, 42 : &#34;Mo&#34;,
                43 : &#34;Tc&#34;, 44 : &#34;Ru&#34;, 45 : &#34;Rh&#34;, 46 : &#34;Pd&#34;,
                47 : &#34;Ag&#34;, 48 : &#34;Cd&#34;, 49 : &#34;In&#34;, 50 : &#34;Sn&#34;,
                51 : &#34;Sb&#34;, 52 : &#34;Te&#34;, 53 : &#34;I&#34;, 54 : &#34;Xe&#34;, 55 : &#34;Cs&#34;,
                56 : &#34;Ba&#34;, 57 : &#34;La&#34;, 58 : &#34;Ce&#34;, 59 : &#34;Pr&#34;,
                60 : &#34;Nd&#34;, 61 : &#34;Pm&#34;, 62 : &#34;Sm&#34;, 63 : &#34;Eu&#34;,
                64 : &#34;Gd&#34;, 65 : &#34;Tb&#34;, 66 : &#34;Dy&#34;, 67 : &#34;Ho&#34;,
                68 : &#34;Er&#34;, 69 : &#34;Tm&#34;, 70 : &#34;Yb&#34;, 71 : &#34;Lu&#34;,
                72 : &#34;Hf&#34;, 73 : &#34;Ta&#34;, 74 : &#34;W&#34;, 75 : &#34;Re&#34;, 76 : &#34;Os&#34;,
                77 : &#34;Ir&#34;, 78 : &#34;Pt&#34;, 79 : &#34;Au&#34;, 80 : &#34;Hg&#34;,
                81 : &#34;Tl&#34;, 82 : &#34;Pb&#34;, 83 : &#34;Bi&#34;, 84 : &#34;Po&#34;,
                85 : &#34;At&#34;, 86 : &#34;Rn&#34;, 87 : &#34;Fr&#34;, 88 : &#34;Ra&#34;,
                89 : &#34;Ac&#34;, 90 : &#34;Th&#34;, 91 : &#34;Pa&#34;, 92 : &#34;U&#34;, 93 : &#34;Np&#34;,
                94 : &#34;Pu&#34;, 95 : &#34;Am&#34;, 96 : &#34;Cm&#34;, 97 : &#34;Bk&#34;,
                98 : &#34;Cf&#34;, 99 : &#34;Es&#34;, 100 : &#34;Fm&#34;, 101 : &#34;Md&#34;,
                102 : &#34;No&#34;, 103 : &#34;Lr&#34;, 104 : &#34;Rf&#34;, 105 : &#34;Db&#34;,
                106 : &#34;Sg&#34;, 107 : &#34;Bh&#34;, 108 : &#34;Hs&#34;, 109 : &#34;Mt&#34;,
                110 : &#34;Ds&#34;, 111 : &#34;Rg&#34;, 112 : &#34;Cn&#34;, 113 : &#34;Nh&#34;,
                114 : &#34;Fl&#34;, 115 : &#34;Mc&#34;, 116 : &#34;Lv&#34;, 117 : &#34;Ts&#34;,
                118 : &#34;Og&#34;
                }

            # Create a pymatgen Structure object using the dummy atom positions
            # created earlier
            dummy_structure = pmg.Structure(lattice=self.lattice,
                                species=species_expanded,
                                coords=fractional_expanded)
            i = 0
            for site in dummy_structure:
                for sp in site.species:
                    if ((not from_cif) and self.ignore_H_atoms \
                                                and self.absorb_H_Z_increase):
                        zs.append(sp.Z+n_H_connected_expanded[i])
                    else:
                        zs.append(sp.Z)
                    try:
                        if ((not from_cif)
                            and self.ignore_H_atoms
                            and self.absorb_H_Z_increase):
                            new_Z = sp.Z+n_H_connected_expanded[i]
                            c = ATOMIC_SCATTERING_PARAMS[atomic_numbers[new_Z]]
                        else:
                            c = ATOMIC_SCATTERING_PARAMS[sp.symbol]
                    except KeyError as no_key:
                        raise ValueError(&#34;Unable to calculate intensity \
                                        calculation prefix arrays&#34;
                                        &#34;there are no scattering coefficients\
                                        for:&#34; &#34; %s.&#34; % sp.symbol) from no_key
                    coeffs.append(c)
                    dwfactors.append(debye_waller_factors.get(sp.symbol, 0))
                    # DOUBLE CHECK THIS IS CORRECT FOR OCCUPANCY != 1
                    occus.append(site[site.specie.symbol])
                i += 1

            zs = np.array(zs)
            coeffs = np.array(coeffs)
            occus = np.array(occus)
            dwfactors = np.array(dwfactors)
            if from_cif:
                self.cif_dwfactors = dwfactors
            else:
                if just_asymmetric:
                    self.dwfactors_asymmetric = dwfactors
                else:
                    self.dwfactors = dwfactors

            g_hkl = np.sqrt(np.sum(np.dot(self.hkl,
                self.lattice.reciprocal_lattice_crystallographic.matrix)**2,
                axis=1))
            # Note that:
            # d_hkl = 1/g_hkl
            # tt = np.rad2deg(2 * np.arcsin(wavelength / (2*d_hkl)))
            # s = sin(theta) / wavelength = 1 / 2d = |ghkl| / 2 (d = 1/|ghkl|)
            # s = g_hkl / 2
            s2 = (g_hkl / 2)**2

            fs = []
            dw_correction = []
            for x in s2:
                fs.append(zs - 41.78214 * x * np.sum(coeffs[:, :, 0] * \
                                        np.exp(-coeffs[:, :, 1] * x), axis=1))
                dw_correction.append(np.exp(-1*dwfactors * x))
            fs = np.array(fs)
            dw_correction = np.array(dw_correction).astype(float)

            prefix = np.empty_like(fs)
            for i in range(fs.shape[0]):
                for j in range(fs.shape[1]):
                    if self.ignore_H_atoms and self.absorb_H_occu_increase:
                        new_occu = ((1 + n_H_connected_expanded[j]) / zs[j])
                        prefix[i][j] = fs[i][j] * occus[j] \
                                                * dw_correction[i][j] \
                                                * new_occu
                    else:
                        prefix[i][j] = fs[i][j] * occus[j] * dw_correction[i][j]

            return prefix

    def get_total_degrees_of_freedom(self, verbose=True):
        &#34;&#34;&#34;
        Once all ZMs have been added to the structure object, interrogate them
        to determine the total number of degrees of freedom.
        This is automatically called by the tensor preparation code, but can
        also be called directly to print out the information.

        Args:
            verbose (bool, optional): Print out the degrees of freedom.
                Defaults to True.
        &#34;&#34;&#34;
        total_dof = 0
        total_external = 0
        total_internal = 0
        total_position = 0
        total_rotation = 0
        for zmat in self.zmatrices:
            total_dof += zmat.degrees_of_freedom
            total_external += zmat.external_degrees_of_freedom
            total_internal += zmat.internal_degrees_of_freedom
            total_position += zmat.position_degrees_of_freedom
            total_rotation += zmat.rotation_degrees_of_freedom
        self.total_degrees_of_freedom = total_dof
        self.total_external_degrees_of_freedom = total_external
        self.total_internal_degrees_of_freedom = total_internal
        self.total_position_degrees_of_freedom = total_position
        self.total_rotation_degrees_of_freedom = total_rotation
        if verbose:
            print(&#34;Total degrees of freedom:&#34;, total_dof)
            print(&#34;Total external degrees of freedom:&#34;, total_external,
                &#34;(pos:&#34;,total_position,&#34;rot:&#34;,total_rotation,&#34;)&#34;)
            print(&#34;Total internal degrees of freedom:&#34;, total_internal)
        zm_torsions = []
        for zmat in self.zmatrices:
            if self.ignore_H_atoms:
                if zmat.internal_degrees_of_freedom &gt; 0:
                    idx = zmat.torsion_refineable_indices_no_H
                    zm_torsions.append(zmat.coords_radians_no_H[:,2][idx])
            else:
                if zmat.internal_degrees_of_freedom &gt; 0:
                    idx = zmat.torsion_refineable_indices
                    zm_torsions.append(zmat.coords_radians[:,2][idx])
        if len(zm_torsions) &gt; 0:
            self.zm_torsions = np.hstack(zm_torsions)
        else:
            self.zm_torsions = np.array([])
        self.total_dof_calculated = True</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gallop.structure.Structure"><code class="flex name class">
<span>class <span class="ident">Structure</span></span>
<span>(</span><span>name='Gallop_structure', ignore_H_atoms=True, absorb_H_Z_increase=False, absorb_H_occu_increase=False)</span>
</code></dt>
<dd>
<div class="desc"><p>The main class used in GALLOP to hold all of the information
about a crystal structure that is needed for SDPD attempts.</p>
<p>Before SDPD can be attempted, the following numpy arrays are
needed:
- hkl = Structure.hkl
- intensities = Structure.intensities
- inverse_covariance_matrix = structure.inverse_covariance_matrix
As well as:
- zmatrices populated with GALLOP Z_matrix objects all of
the ZMs in the asymmetric unit
Stored in Structure.zmatrices (list of Z-matrix objects)
- Structure.lattice = pymatgen lattice
- Structure.space_group = pymatgen space_group
- Structure.sg_number = sg_number (integer)
- Structure.centrosymmetric = centrosymmetric (bool)</p>
<p>If using files generated by Pawley fitting the data with DASH, GSAS-II or
TOPAS, helper functions are available to automate the population of
the required arrays and parameters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The root name to be used for
writing CIFs during SDPD attempts. Defaults to
"Gallop_structure".</dd>
<dt><strong><code>ignore_H_atoms</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Ignore H-atoms during
SDPD. Setting this to True, and
absorb_H_occu_increase and absorb_H_Z_increase to
False will simply ignore the presence of H atoms.
Defaults to True.</dd>
<dt><strong><code>absorb_H_Z_increase</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If ignore_H_atoms,
offset the loss of electrons in unit cell by
increasing the atomic number of the non-H atoms by
the number of connected H atoms. Defaults to False.</dd>
<dt><strong><code>absorb_H_occu_increase</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If ignore_H_atoms,
offset the loss of electrons in the unit cell by
increasing the occupancy of the non-H atoms by
a factor of (1 + n_H_connected_expanded)/non_H(Z).
Defaults to False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Structure(object):
    &#34;&#34;&#34;
    The main class used in GALLOP to hold all of the information
    about a crystal structure that is needed for SDPD attempts.

    Before SDPD can be attempted, the following numpy arrays are
    needed:
        - hkl = Structure.hkl
        - intensities = Structure.intensities
        - inverse_covariance_matrix = structure.inverse_covariance_matrix
    As well as:
        - zmatrices populated with GALLOP Z_matrix objects all of
            the ZMs in the asymmetric unit
            Stored in Structure.zmatrices (list of Z-matrix objects)
        - Structure.lattice = pymatgen lattice
        - Structure.space_group = pymatgen space_group
        - Structure.sg_number = sg_number (integer)
        - Structure.centrosymmetric = centrosymmetric (bool)

    If using files generated by Pawley fitting the data with DASH, GSAS-II or
    TOPAS, helper functions are available to automate the population of
    the required arrays and parameters.

    &#34;&#34;&#34;
    def __init__(self, name=&#34;Gallop_structure&#34;, ignore_H_atoms=True,
                    absorb_H_Z_increase=False, absorb_H_occu_increase=False):
        &#34;&#34;&#34;
        Args:
            name (str, optional): The root name to be used for
                writing CIFs during SDPD attempts. Defaults to
                &#34;Gallop_structure&#34;.
            ignore_H_atoms (bool, optional): Ignore H-atoms during
                SDPD. Setting this to True, and
                absorb_H_occu_increase and absorb_H_Z_increase to
                False will simply ignore the presence of H atoms.
                Defaults to True.
            absorb_H_Z_increase (bool, optional): If ignore_H_atoms,
                offset the loss of electrons in unit cell by
                increasing the atomic number of the non-H atoms by
                the number of connected H atoms. Defaults to False.
            absorb_H_occu_increase (bool, optional): If ignore_H_atoms,
                offset the loss of electrons in the unit cell by
                increasing the occupancy of the non-H atoms by
                a factor of (1 + n_H_connected_expanded)/non_H(Z).
                Defaults to False.
        &#34;&#34;&#34;
        self.name = name
        self.ignore_H_atoms = ignore_H_atoms
        self.output_filename_root = name
        self.zmatrices = []
        self.absorb_H_Z_increase = absorb_H_Z_increase
        self.absorb_H_occu_increase = absorb_H_occu_increase

        self.original_sg_number = None
        self.total_dof_calculated = False
        self.sg_number = None
        self.wavelength = None
        self.hkl = None
        self.twotheta = []
        self.space_group = None
        self.lattice = None
        self.cif_frac_coords_no_H = None
        self.cif_species_no_H = None
        self.cif_frac_coords = None
        self.cif_species = None
        self.data_file = None
        self.dspacing = None
        self.data_resolution = None
        self.source = None
        self.centrosymmetric = None
        self.affine_matrices = None
        self.cif_dwfactors = None
        self.dwfactors_asymmetric = None
        self.dwfactors = None
        self.total_degrees_of_freedom = None
        self.total_external_degrees_of_freedom = None
        self.total_internal_degrees_of_freedom = None
        self.total_position_degrees_of_freedom = None
        self.total_rotation_degrees_of_freedom = None
        self.zm_torsions = None

    def __repr__(self):
        return self.name

    def to_json(self, return_json=True):
        &#34;&#34;&#34;
        Save a structure object to a JSON formatted string. Can then be used to
        instantiate a structure object from a string (or file)

        Args:
            return_json (bool, optional): If True, return a JSON formatted
                string, else return a dictionary. Default is True.

        Returns:
            dict or str: JSON-compatible dict or JSON formatted string
        &#34;&#34;&#34;
        dumpable = {}
        for k, v in self.__dict__.items():
            if k in [&#34;zmatrices&#34;, &#34;lattice&#34;, &#34;space_group&#34;]:
                if k == &#34;zmatrices&#34;:
                    dumpable[k] = [zm.to_json(return_json=return_json) for zm in v]
                elif k == &#34;lattice&#34;:
                    dumpable[k] = v.as_dict()
            else:
                if isinstance(v, np.ndarray):
                    dumpable[k] = [v.tolist(), True]
                elif isinstance(v, np.int32):
                    dumpable[k] = [int(v), False]
                else:
                    dumpable[k] = [v, False]
        if return_json:
            return json.dumps(dumpable)
        else:
            return dumpable

    def from_json(self, attributes, is_json=True):
        &#34;&#34;&#34;
        Load a structure object from JSON formatted string

        Args:
            attributes (str or dict): JSON formatted string of a structure
                                    produced by the to_json method
            is_json (bool, optional): Toggles reading dict directly or using a
                JSON formatted string. Default is True
        &#34;&#34;&#34;
        if is_json:
            attributes = json.loads(attributes)
        for k, v in attributes.items():
            if k in [&#34;zmatrices&#34;, &#34;lattice&#34;, &#34;space_group&#34;]:
                if k == &#34;zmatrices&#34;:
                    zmatrices = []
                    for zmstring in v:
                        zmat = zm.Z_matrix()
                        zmat.from_json(zmstring, is_json=is_json)
                        zmatrices.append(zmat)
                    setattr(self, k, zmatrices)
                elif k == &#34;lattice&#34;:
                    lattice = pmg.Lattice.from_dict(v)
                    setattr(self,k,lattice)
            else:
                if v[1]:
                    setattr(self, k, np.array(v[0]))
                else:
                    setattr(self, k, v[0])
        setattr(self, &#34;space_group&#34;,
                        groups.SpaceGroup.from_int_number(self.sg_number))

    def add_zmatrix(self, filename, verbose=True):
        &#34;&#34;&#34;
        Create and add a z-matrix object to the Structure

        Args:
            filename (str): filename of the Z-matrix
            verbose (bool, optional): Print out information. Defaults to True.
        &#34;&#34;&#34;
        self.zmatrices.append(zm.Z_matrix(filename))
        if verbose:
            print(&#34;Added Z-matrix with&#34;,self.zmatrices[-1])

    def get_resolution(self, twotheta, decimal_places=3):
        &#34;&#34;&#34;
        Calculate the d-spacing of a given twotheta value using Bragg&#39;s law

        Args:
            twotheta (float): The twotheta value of interest
            decimal_places (int, optional): Number of decimal_places to restrict
                the result to. Defaults to 3.

        Returns:
            float: the d-spacing of a twotheta value
        &#34;&#34;&#34;
        d = self.wavelength / (2*np.sin(np.deg2rad(twotheta/2)))
        return (np.around(d, decimal_places))

    def add_data(self, filename, source=&#34;DASH&#34;,
                percentage_cutoff=20):
        &#34;&#34;&#34;
        Add PXRD data to a Z-matrix

        Args:
            filename (str): filename of file from which to read the data
            source (str, optional): data source. Currently only &#34;DASH&#34; is
                accepted as an argument. More programs may be added in the
                future. Defaults to &#34;DASH&#34;.
            percentage_cutoff_hcv (int, optional): the minimum percentage
            correlation to be included in the inverse covariance
            matrix. Defaults to 20 to be comparable with DASH,
            however, this doesn&#39;t affect the speed of GALLOP so can
            be set as desired without impacting performance.
        &#34;&#34;&#34;
        self.data_file = filename
        if source.lower() == &#34;dash&#34;:
            data = files.get_data_from_DASH_sdi(filename,
                        percentage_cutoff_inv_cov=percentage_cutoff)
            for k, v in data.items():
                setattr(self, k, v)
            self.dspacing = self.get_resolution(self.twotheta)
            self.data_resolution = self.get_resolution(self.twotheta[-1])
            self.source = &#34;dash&#34;
        elif &#34;gsas&#34; in source.lower():
            data = files.get_data_from_GSAS_gpx(filename,
                            percentage_cutoff_inv_cov=percentage_cutoff)
            for k, v in data.items():
                setattr(self, k, v)
            self.data_resolution = self.dspacing[-1]
            self.source = &#34;gsas&#34;
        elif &#34;topas&#34; == source.lower():
            data = files.get_data_from_TOPAS_output(filename,
                            percentage_cutoff_inv_cov=percentage_cutoff)
            for k, v in data.items():
                setattr(self, k, v)
            self.source = &#34;topas&#34;
        else:
            print(&#34;This program is not yet supported.&#34;)
            print(&#34;Currently supported programs:&#34;)
            print(&#34; - DASH&#34;)
            print(&#34; - GSAS-II&#34;)
            print(&#34; - TOPAS&#34;)
        self.centrosymmetric = self.check_centre_of_symmetry()
        self.affine_matrices = self.get_affine_matrices()

    def check_centre_of_symmetry(self):
        &#34;&#34;&#34;
        Check if a structure is centrosymmetric

        Returns:
            bool: True if centrosymmetric
        &#34;&#34;&#34;
        laue = [&#34;-1&#34;, &#34;2/m&#34;, &#34;mmm&#34;, &#34;4/m&#34;, &#34;4/mmm&#34;,
                    &#34;-3&#34;, &#34;-3m&#34;, &#34;6/m&#34;, &#34;6/mmm&#34;, &#34;m-3&#34;, &#34;m-3m&#34;]
        return self.space_group.point_group in laue

    def get_affine_matrices(self):
        &#34;&#34;&#34;
        Get the affine matrices of the space group
        Used as a fall-back (generic) method for structure factor
        calculation.

        GALLOP Structure must have a pymatgen space_group assigned

        Returns:
            numpy array:    affine matrices for the space group
                            of shape (n,4,4) where n is the number
                            of equivalent positions for the space
                            group.
        &#34;&#34;&#34;
        affine_matrices = []
        for op in self.space_group.symmetry_ops:
            affine_matrices.append(op.affine_matrix)
        return np.array(affine_matrices)

    def generate_intensity_calculation_prefix(self,
                                            debye_waller_factors=None,
                                            just_asymmetric=False,
                                            from_cif=False):
        &#34;&#34;&#34;
        Much of this code is directly adapted from the PyMatGen code
        for PXRD pattern generation, which can be found here:
        https://pymatgen.org/pymatgen.analysis.diffraction.xrd.html
        A few modifications have been made. For example, ability to &#34;absorb&#34;
        H atoms by increasing the atomic number used to calculate
        atomic form factors, or increase the occupancy of the non-H
        atoms.

        If reading directly from a CIF then the atomic coordinates
        are used. If not reading from a CIF, then a dummy structure
        is created in order to extract the required information.
        This can either just be the atoms in the asymmetric unit,
        or the whole unit cell.
        &#34;&#34;&#34;
        if debye_waller_factors is None:
            debye_waller_factors = {}
        if len(self.zmatrices) == 0 and not from_cif:
            print(&#34;No Z-matrices have been added!&#34;)
        else:
            if not from_cif:
                all_atoms_coords = []
                all_atoms_elements = []
                all_atoms_n_H_connected = []
                for zmat in self.zmatrices:
                    if self.ignore_H_atoms:
                        all_atoms_coords.append(
                            zmat.initial_cartesian_no_H)
                        all_atoms_elements.append(
                            zmat.elements_no_H)
                        all_atoms_n_H_connected.append(
                            zmat.n_H_connected)
                    else:
                        all_atoms_coords.append(zmat.initial_cartesian)
                        all_atoms_elements.append(zmat.elements)

                all_atoms_coords = np.vstack(all_atoms_coords)
                all_atoms_elements = np.hstack(all_atoms_elements)
                if self.ignore_H_atoms:
                    all_atoms_n_H_connected = np.hstack(all_atoms_n_H_connected)
                else:
                    all_atoms_n_H_connected = np.array(all_atoms_n_H_connected)

                fractional_coords = np.dot(all_atoms_coords,
                                                        self.lattice.inv_matrix)
            else:
                if self.ignore_H_atoms:
                    fractional_coords = self.cif_frac_coords_no_H
                    all_atoms_elements = self.cif_species_no_H
                else:
                    fractional_coords = self.cif_frac_coords
                    all_atoms_elements = self.cif_species
                just_asymmetric = True

            if not just_asymmetric:
                # Apply symmetry of space group to locate all atoms
                # within the unit cell. This is a dummy structure,
                # and the purpose is only to extract the atomic
                # scattering parameters etc, which are independent
                # of position in the unit cell.
                species_expanded = []
                fractional_expanded = []
                n_H_connected_expanded = []
                xyzw = np.vstack((fractional_coords.T, np.ones((1,
                                    fractional_coords.shape[0]))))
                for am in self.affine_matrices:
                    expanded = np.array(np.dot(am, xyzw).T)
                    fractional_expanded.append(expanded[:,:3])
                    species_expanded.append(all_atoms_elements)
                    n_H_connected_expanded.append(all_atoms_n_H_connected)
                species_expanded = np.array(species_expanded).ravel()
                fractional_expanded = np.vstack(fractional_expanded)
                n_H_connected_expanded = np.hstack(n_H_connected_expanded)
            else:
                species_expanded = all_atoms_elements
                fractional_expanded = fractional_coords
                if not from_cif:
                    n_H_connected_expanded = all_atoms_n_H_connected

            with open(
                os.path.join(&#34;gallop&#34;,&#34;atomic_scattering_params.json&#34;)) as f:
                ATOMIC_SCATTERING_PARAMS = json.load(f)
            f.close()

            zs = []
            coeffs = []
            occus = []
            dwfactors = []
            atomic_numbers = {
                1 : &#34;H&#34;, 2 : &#34;He&#34;, 3 : &#34;Li&#34;, 4 : &#34;Be&#34;, 5 : &#34;B&#34;,
                6 : &#34;C&#34;, 7 : &#34;N&#34;, 8 : &#34;O&#34;, 9 : &#34;F&#34;, 10 : &#34;Ne&#34;,
                11 : &#34;Na&#34;, 12 : &#34;Mg&#34;, 13 : &#34;Al&#34;, 14 : &#34;Si&#34;, 15 : &#34;P&#34;,
                16 : &#34;S&#34;, 17 : &#34;Cl&#34;, 18 : &#34;Ar&#34;, 19 : &#34;K&#34;, 20 : &#34;Ca&#34;,
                21 : &#34;Sc&#34;, 22 : &#34;Ti&#34;, 23 : &#34;V&#34;, 24 : &#34;Cr&#34;, 25 : &#34;Mn&#34;,
                26 : &#34;Fe&#34;, 27 : &#34;Co&#34;, 28 : &#34;Ni&#34;, 29 : &#34;Cu&#34;,
                30 : &#34;Zn&#34;, 31 : &#34;Ga&#34;, 32 : &#34;Ge&#34;, 33 : &#34;As&#34;,
                34 : &#34;Se&#34;, 35 : &#34;Br&#34;, 36 : &#34;Kr&#34;, 37 : &#34;Rb&#34;,
                38 : &#34;Sr&#34;, 39 : &#34;Y&#34;, 40 : &#34;Zr&#34;, 41 : &#34;Nb&#34;, 42 : &#34;Mo&#34;,
                43 : &#34;Tc&#34;, 44 : &#34;Ru&#34;, 45 : &#34;Rh&#34;, 46 : &#34;Pd&#34;,
                47 : &#34;Ag&#34;, 48 : &#34;Cd&#34;, 49 : &#34;In&#34;, 50 : &#34;Sn&#34;,
                51 : &#34;Sb&#34;, 52 : &#34;Te&#34;, 53 : &#34;I&#34;, 54 : &#34;Xe&#34;, 55 : &#34;Cs&#34;,
                56 : &#34;Ba&#34;, 57 : &#34;La&#34;, 58 : &#34;Ce&#34;, 59 : &#34;Pr&#34;,
                60 : &#34;Nd&#34;, 61 : &#34;Pm&#34;, 62 : &#34;Sm&#34;, 63 : &#34;Eu&#34;,
                64 : &#34;Gd&#34;, 65 : &#34;Tb&#34;, 66 : &#34;Dy&#34;, 67 : &#34;Ho&#34;,
                68 : &#34;Er&#34;, 69 : &#34;Tm&#34;, 70 : &#34;Yb&#34;, 71 : &#34;Lu&#34;,
                72 : &#34;Hf&#34;, 73 : &#34;Ta&#34;, 74 : &#34;W&#34;, 75 : &#34;Re&#34;, 76 : &#34;Os&#34;,
                77 : &#34;Ir&#34;, 78 : &#34;Pt&#34;, 79 : &#34;Au&#34;, 80 : &#34;Hg&#34;,
                81 : &#34;Tl&#34;, 82 : &#34;Pb&#34;, 83 : &#34;Bi&#34;, 84 : &#34;Po&#34;,
                85 : &#34;At&#34;, 86 : &#34;Rn&#34;, 87 : &#34;Fr&#34;, 88 : &#34;Ra&#34;,
                89 : &#34;Ac&#34;, 90 : &#34;Th&#34;, 91 : &#34;Pa&#34;, 92 : &#34;U&#34;, 93 : &#34;Np&#34;,
                94 : &#34;Pu&#34;, 95 : &#34;Am&#34;, 96 : &#34;Cm&#34;, 97 : &#34;Bk&#34;,
                98 : &#34;Cf&#34;, 99 : &#34;Es&#34;, 100 : &#34;Fm&#34;, 101 : &#34;Md&#34;,
                102 : &#34;No&#34;, 103 : &#34;Lr&#34;, 104 : &#34;Rf&#34;, 105 : &#34;Db&#34;,
                106 : &#34;Sg&#34;, 107 : &#34;Bh&#34;, 108 : &#34;Hs&#34;, 109 : &#34;Mt&#34;,
                110 : &#34;Ds&#34;, 111 : &#34;Rg&#34;, 112 : &#34;Cn&#34;, 113 : &#34;Nh&#34;,
                114 : &#34;Fl&#34;, 115 : &#34;Mc&#34;, 116 : &#34;Lv&#34;, 117 : &#34;Ts&#34;,
                118 : &#34;Og&#34;
                }

            # Create a pymatgen Structure object using the dummy atom positions
            # created earlier
            dummy_structure = pmg.Structure(lattice=self.lattice,
                                species=species_expanded,
                                coords=fractional_expanded)
            i = 0
            for site in dummy_structure:
                for sp in site.species:
                    if ((not from_cif) and self.ignore_H_atoms \
                                                and self.absorb_H_Z_increase):
                        zs.append(sp.Z+n_H_connected_expanded[i])
                    else:
                        zs.append(sp.Z)
                    try:
                        if ((not from_cif)
                            and self.ignore_H_atoms
                            and self.absorb_H_Z_increase):
                            new_Z = sp.Z+n_H_connected_expanded[i]
                            c = ATOMIC_SCATTERING_PARAMS[atomic_numbers[new_Z]]
                        else:
                            c = ATOMIC_SCATTERING_PARAMS[sp.symbol]
                    except KeyError as no_key:
                        raise ValueError(&#34;Unable to calculate intensity \
                                        calculation prefix arrays&#34;
                                        &#34;there are no scattering coefficients\
                                        for:&#34; &#34; %s.&#34; % sp.symbol) from no_key
                    coeffs.append(c)
                    dwfactors.append(debye_waller_factors.get(sp.symbol, 0))
                    # DOUBLE CHECK THIS IS CORRECT FOR OCCUPANCY != 1
                    occus.append(site[site.specie.symbol])
                i += 1

            zs = np.array(zs)
            coeffs = np.array(coeffs)
            occus = np.array(occus)
            dwfactors = np.array(dwfactors)
            if from_cif:
                self.cif_dwfactors = dwfactors
            else:
                if just_asymmetric:
                    self.dwfactors_asymmetric = dwfactors
                else:
                    self.dwfactors = dwfactors

            g_hkl = np.sqrt(np.sum(np.dot(self.hkl,
                self.lattice.reciprocal_lattice_crystallographic.matrix)**2,
                axis=1))
            # Note that:
            # d_hkl = 1/g_hkl
            # tt = np.rad2deg(2 * np.arcsin(wavelength / (2*d_hkl)))
            # s = sin(theta) / wavelength = 1 / 2d = |ghkl| / 2 (d = 1/|ghkl|)
            # s = g_hkl / 2
            s2 = (g_hkl / 2)**2

            fs = []
            dw_correction = []
            for x in s2:
                fs.append(zs - 41.78214 * x * np.sum(coeffs[:, :, 0] * \
                                        np.exp(-coeffs[:, :, 1] * x), axis=1))
                dw_correction.append(np.exp(-1*dwfactors * x))
            fs = np.array(fs)
            dw_correction = np.array(dw_correction).astype(float)

            prefix = np.empty_like(fs)
            for i in range(fs.shape[0]):
                for j in range(fs.shape[1]):
                    if self.ignore_H_atoms and self.absorb_H_occu_increase:
                        new_occu = ((1 + n_H_connected_expanded[j]) / zs[j])
                        prefix[i][j] = fs[i][j] * occus[j] \
                                                * dw_correction[i][j] \
                                                * new_occu
                    else:
                        prefix[i][j] = fs[i][j] * occus[j] * dw_correction[i][j]

            return prefix

    def get_total_degrees_of_freedom(self, verbose=True):
        &#34;&#34;&#34;
        Once all ZMs have been added to the structure object, interrogate them
        to determine the total number of degrees of freedom.
        This is automatically called by the tensor preparation code, but can
        also be called directly to print out the information.

        Args:
            verbose (bool, optional): Print out the degrees of freedom.
                Defaults to True.
        &#34;&#34;&#34;
        total_dof = 0
        total_external = 0
        total_internal = 0
        total_position = 0
        total_rotation = 0
        for zmat in self.zmatrices:
            total_dof += zmat.degrees_of_freedom
            total_external += zmat.external_degrees_of_freedom
            total_internal += zmat.internal_degrees_of_freedom
            total_position += zmat.position_degrees_of_freedom
            total_rotation += zmat.rotation_degrees_of_freedom
        self.total_degrees_of_freedom = total_dof
        self.total_external_degrees_of_freedom = total_external
        self.total_internal_degrees_of_freedom = total_internal
        self.total_position_degrees_of_freedom = total_position
        self.total_rotation_degrees_of_freedom = total_rotation
        if verbose:
            print(&#34;Total degrees of freedom:&#34;, total_dof)
            print(&#34;Total external degrees of freedom:&#34;, total_external,
                &#34;(pos:&#34;,total_position,&#34;rot:&#34;,total_rotation,&#34;)&#34;)
            print(&#34;Total internal degrees of freedom:&#34;, total_internal)
        zm_torsions = []
        for zmat in self.zmatrices:
            if self.ignore_H_atoms:
                if zmat.internal_degrees_of_freedom &gt; 0:
                    idx = zmat.torsion_refineable_indices_no_H
                    zm_torsions.append(zmat.coords_radians_no_H[:,2][idx])
            else:
                if zmat.internal_degrees_of_freedom &gt; 0:
                    idx = zmat.torsion_refineable_indices
                    zm_torsions.append(zmat.coords_radians[:,2][idx])
        if len(zm_torsions) &gt; 0:
            self.zm_torsions = np.hstack(zm_torsions)
        else:
            self.zm_torsions = np.array([])
        self.total_dof_calculated = True</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="gallop.structure.Structure.add_data"><code class="name flex">
<span>def <span class="ident">add_data</span></span>(<span>self, filename, source='DASH', percentage_cutoff=20)</span>
</code></dt>
<dd>
<div class="desc"><p>Add PXRD data to a Z-matrix</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>filename of file from which to read the data</dd>
<dt><strong><code>source</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>data source. Currently only "DASH" is
accepted as an argument. More programs may be added in the
future. Defaults to "DASH".</dd>
<dt><strong><code>percentage_cutoff_hcv</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>the minimum percentage</dd>
</dl>
<p>correlation to be included in the inverse covariance
matrix. Defaults to 20 to be comparable with DASH,
however, this doesn't affect the speed of GALLOP so can
be set as desired without impacting performance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_data(self, filename, source=&#34;DASH&#34;,
            percentage_cutoff=20):
    &#34;&#34;&#34;
    Add PXRD data to a Z-matrix

    Args:
        filename (str): filename of file from which to read the data
        source (str, optional): data source. Currently only &#34;DASH&#34; is
            accepted as an argument. More programs may be added in the
            future. Defaults to &#34;DASH&#34;.
        percentage_cutoff_hcv (int, optional): the minimum percentage
        correlation to be included in the inverse covariance
        matrix. Defaults to 20 to be comparable with DASH,
        however, this doesn&#39;t affect the speed of GALLOP so can
        be set as desired without impacting performance.
    &#34;&#34;&#34;
    self.data_file = filename
    if source.lower() == &#34;dash&#34;:
        data = files.get_data_from_DASH_sdi(filename,
                    percentage_cutoff_inv_cov=percentage_cutoff)
        for k, v in data.items():
            setattr(self, k, v)
        self.dspacing = self.get_resolution(self.twotheta)
        self.data_resolution = self.get_resolution(self.twotheta[-1])
        self.source = &#34;dash&#34;
    elif &#34;gsas&#34; in source.lower():
        data = files.get_data_from_GSAS_gpx(filename,
                        percentage_cutoff_inv_cov=percentage_cutoff)
        for k, v in data.items():
            setattr(self, k, v)
        self.data_resolution = self.dspacing[-1]
        self.source = &#34;gsas&#34;
    elif &#34;topas&#34; == source.lower():
        data = files.get_data_from_TOPAS_output(filename,
                        percentage_cutoff_inv_cov=percentage_cutoff)
        for k, v in data.items():
            setattr(self, k, v)
        self.source = &#34;topas&#34;
    else:
        print(&#34;This program is not yet supported.&#34;)
        print(&#34;Currently supported programs:&#34;)
        print(&#34; - DASH&#34;)
        print(&#34; - GSAS-II&#34;)
        print(&#34; - TOPAS&#34;)
    self.centrosymmetric = self.check_centre_of_symmetry()
    self.affine_matrices = self.get_affine_matrices()</code></pre>
</details>
</dd>
<dt id="gallop.structure.Structure.add_zmatrix"><code class="name flex">
<span>def <span class="ident">add_zmatrix</span></span>(<span>self, filename, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Create and add a z-matrix object to the Structure</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>str</code></dt>
<dd>filename of the Z-matrix</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Print out information. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_zmatrix(self, filename, verbose=True):
    &#34;&#34;&#34;
    Create and add a z-matrix object to the Structure

    Args:
        filename (str): filename of the Z-matrix
        verbose (bool, optional): Print out information. Defaults to True.
    &#34;&#34;&#34;
    self.zmatrices.append(zm.Z_matrix(filename))
    if verbose:
        print(&#34;Added Z-matrix with&#34;,self.zmatrices[-1])</code></pre>
</details>
</dd>
<dt id="gallop.structure.Structure.check_centre_of_symmetry"><code class="name flex">
<span>def <span class="ident">check_centre_of_symmetry</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Check if a structure is centrosymmetric</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if centrosymmetric</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_centre_of_symmetry(self):
    &#34;&#34;&#34;
    Check if a structure is centrosymmetric

    Returns:
        bool: True if centrosymmetric
    &#34;&#34;&#34;
    laue = [&#34;-1&#34;, &#34;2/m&#34;, &#34;mmm&#34;, &#34;4/m&#34;, &#34;4/mmm&#34;,
                &#34;-3&#34;, &#34;-3m&#34;, &#34;6/m&#34;, &#34;6/mmm&#34;, &#34;m-3&#34;, &#34;m-3m&#34;]
    return self.space_group.point_group in laue</code></pre>
</details>
</dd>
<dt id="gallop.structure.Structure.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, attributes, is_json=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a structure object from JSON formatted string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>attributes</code></strong> :&ensp;<code>str</code> or <code>dict</code></dt>
<dd>JSON formatted string of a structure
produced by the to_json method</dd>
<dt><strong><code>is_json</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Toggles reading dict directly or using a
JSON formatted string. Default is True</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, attributes, is_json=True):
    &#34;&#34;&#34;
    Load a structure object from JSON formatted string

    Args:
        attributes (str or dict): JSON formatted string of a structure
                                produced by the to_json method
        is_json (bool, optional): Toggles reading dict directly or using a
            JSON formatted string. Default is True
    &#34;&#34;&#34;
    if is_json:
        attributes = json.loads(attributes)
    for k, v in attributes.items():
        if k in [&#34;zmatrices&#34;, &#34;lattice&#34;, &#34;space_group&#34;]:
            if k == &#34;zmatrices&#34;:
                zmatrices = []
                for zmstring in v:
                    zmat = zm.Z_matrix()
                    zmat.from_json(zmstring, is_json=is_json)
                    zmatrices.append(zmat)
                setattr(self, k, zmatrices)
            elif k == &#34;lattice&#34;:
                lattice = pmg.Lattice.from_dict(v)
                setattr(self,k,lattice)
        else:
            if v[1]:
                setattr(self, k, np.array(v[0]))
            else:
                setattr(self, k, v[0])
    setattr(self, &#34;space_group&#34;,
                    groups.SpaceGroup.from_int_number(self.sg_number))</code></pre>
</details>
</dd>
<dt id="gallop.structure.Structure.generate_intensity_calculation_prefix"><code class="name flex">
<span>def <span class="ident">generate_intensity_calculation_prefix</span></span>(<span>self, debye_waller_factors=None, just_asymmetric=False, from_cif=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Much of this code is directly adapted from the PyMatGen code
for PXRD pattern generation, which can be found here:
<a href="https://pymatgen.org/pymatgen.analysis.diffraction.xrd.html">https://pymatgen.org/pymatgen.analysis.diffraction.xrd.html</a>
A few modifications have been made. For example, ability to "absorb"
H atoms by increasing the atomic number used to calculate
atomic form factors, or increase the occupancy of the non-H
atoms.</p>
<p>If reading directly from a CIF then the atomic coordinates
are used. If not reading from a CIF, then a dummy structure
is created in order to extract the required information.
This can either just be the atoms in the asymmetric unit,
or the whole unit cell.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_intensity_calculation_prefix(self,
                                        debye_waller_factors=None,
                                        just_asymmetric=False,
                                        from_cif=False):
    &#34;&#34;&#34;
    Much of this code is directly adapted from the PyMatGen code
    for PXRD pattern generation, which can be found here:
    https://pymatgen.org/pymatgen.analysis.diffraction.xrd.html
    A few modifications have been made. For example, ability to &#34;absorb&#34;
    H atoms by increasing the atomic number used to calculate
    atomic form factors, or increase the occupancy of the non-H
    atoms.

    If reading directly from a CIF then the atomic coordinates
    are used. If not reading from a CIF, then a dummy structure
    is created in order to extract the required information.
    This can either just be the atoms in the asymmetric unit,
    or the whole unit cell.
    &#34;&#34;&#34;
    if debye_waller_factors is None:
        debye_waller_factors = {}
    if len(self.zmatrices) == 0 and not from_cif:
        print(&#34;No Z-matrices have been added!&#34;)
    else:
        if not from_cif:
            all_atoms_coords = []
            all_atoms_elements = []
            all_atoms_n_H_connected = []
            for zmat in self.zmatrices:
                if self.ignore_H_atoms:
                    all_atoms_coords.append(
                        zmat.initial_cartesian_no_H)
                    all_atoms_elements.append(
                        zmat.elements_no_H)
                    all_atoms_n_H_connected.append(
                        zmat.n_H_connected)
                else:
                    all_atoms_coords.append(zmat.initial_cartesian)
                    all_atoms_elements.append(zmat.elements)

            all_atoms_coords = np.vstack(all_atoms_coords)
            all_atoms_elements = np.hstack(all_atoms_elements)
            if self.ignore_H_atoms:
                all_atoms_n_H_connected = np.hstack(all_atoms_n_H_connected)
            else:
                all_atoms_n_H_connected = np.array(all_atoms_n_H_connected)

            fractional_coords = np.dot(all_atoms_coords,
                                                    self.lattice.inv_matrix)
        else:
            if self.ignore_H_atoms:
                fractional_coords = self.cif_frac_coords_no_H
                all_atoms_elements = self.cif_species_no_H
            else:
                fractional_coords = self.cif_frac_coords
                all_atoms_elements = self.cif_species
            just_asymmetric = True

        if not just_asymmetric:
            # Apply symmetry of space group to locate all atoms
            # within the unit cell. This is a dummy structure,
            # and the purpose is only to extract the atomic
            # scattering parameters etc, which are independent
            # of position in the unit cell.
            species_expanded = []
            fractional_expanded = []
            n_H_connected_expanded = []
            xyzw = np.vstack((fractional_coords.T, np.ones((1,
                                fractional_coords.shape[0]))))
            for am in self.affine_matrices:
                expanded = np.array(np.dot(am, xyzw).T)
                fractional_expanded.append(expanded[:,:3])
                species_expanded.append(all_atoms_elements)
                n_H_connected_expanded.append(all_atoms_n_H_connected)
            species_expanded = np.array(species_expanded).ravel()
            fractional_expanded = np.vstack(fractional_expanded)
            n_H_connected_expanded = np.hstack(n_H_connected_expanded)
        else:
            species_expanded = all_atoms_elements
            fractional_expanded = fractional_coords
            if not from_cif:
                n_H_connected_expanded = all_atoms_n_H_connected

        with open(
            os.path.join(&#34;gallop&#34;,&#34;atomic_scattering_params.json&#34;)) as f:
            ATOMIC_SCATTERING_PARAMS = json.load(f)
        f.close()

        zs = []
        coeffs = []
        occus = []
        dwfactors = []
        atomic_numbers = {
            1 : &#34;H&#34;, 2 : &#34;He&#34;, 3 : &#34;Li&#34;, 4 : &#34;Be&#34;, 5 : &#34;B&#34;,
            6 : &#34;C&#34;, 7 : &#34;N&#34;, 8 : &#34;O&#34;, 9 : &#34;F&#34;, 10 : &#34;Ne&#34;,
            11 : &#34;Na&#34;, 12 : &#34;Mg&#34;, 13 : &#34;Al&#34;, 14 : &#34;Si&#34;, 15 : &#34;P&#34;,
            16 : &#34;S&#34;, 17 : &#34;Cl&#34;, 18 : &#34;Ar&#34;, 19 : &#34;K&#34;, 20 : &#34;Ca&#34;,
            21 : &#34;Sc&#34;, 22 : &#34;Ti&#34;, 23 : &#34;V&#34;, 24 : &#34;Cr&#34;, 25 : &#34;Mn&#34;,
            26 : &#34;Fe&#34;, 27 : &#34;Co&#34;, 28 : &#34;Ni&#34;, 29 : &#34;Cu&#34;,
            30 : &#34;Zn&#34;, 31 : &#34;Ga&#34;, 32 : &#34;Ge&#34;, 33 : &#34;As&#34;,
            34 : &#34;Se&#34;, 35 : &#34;Br&#34;, 36 : &#34;Kr&#34;, 37 : &#34;Rb&#34;,
            38 : &#34;Sr&#34;, 39 : &#34;Y&#34;, 40 : &#34;Zr&#34;, 41 : &#34;Nb&#34;, 42 : &#34;Mo&#34;,
            43 : &#34;Tc&#34;, 44 : &#34;Ru&#34;, 45 : &#34;Rh&#34;, 46 : &#34;Pd&#34;,
            47 : &#34;Ag&#34;, 48 : &#34;Cd&#34;, 49 : &#34;In&#34;, 50 : &#34;Sn&#34;,
            51 : &#34;Sb&#34;, 52 : &#34;Te&#34;, 53 : &#34;I&#34;, 54 : &#34;Xe&#34;, 55 : &#34;Cs&#34;,
            56 : &#34;Ba&#34;, 57 : &#34;La&#34;, 58 : &#34;Ce&#34;, 59 : &#34;Pr&#34;,
            60 : &#34;Nd&#34;, 61 : &#34;Pm&#34;, 62 : &#34;Sm&#34;, 63 : &#34;Eu&#34;,
            64 : &#34;Gd&#34;, 65 : &#34;Tb&#34;, 66 : &#34;Dy&#34;, 67 : &#34;Ho&#34;,
            68 : &#34;Er&#34;, 69 : &#34;Tm&#34;, 70 : &#34;Yb&#34;, 71 : &#34;Lu&#34;,
            72 : &#34;Hf&#34;, 73 : &#34;Ta&#34;, 74 : &#34;W&#34;, 75 : &#34;Re&#34;, 76 : &#34;Os&#34;,
            77 : &#34;Ir&#34;, 78 : &#34;Pt&#34;, 79 : &#34;Au&#34;, 80 : &#34;Hg&#34;,
            81 : &#34;Tl&#34;, 82 : &#34;Pb&#34;, 83 : &#34;Bi&#34;, 84 : &#34;Po&#34;,
            85 : &#34;At&#34;, 86 : &#34;Rn&#34;, 87 : &#34;Fr&#34;, 88 : &#34;Ra&#34;,
            89 : &#34;Ac&#34;, 90 : &#34;Th&#34;, 91 : &#34;Pa&#34;, 92 : &#34;U&#34;, 93 : &#34;Np&#34;,
            94 : &#34;Pu&#34;, 95 : &#34;Am&#34;, 96 : &#34;Cm&#34;, 97 : &#34;Bk&#34;,
            98 : &#34;Cf&#34;, 99 : &#34;Es&#34;, 100 : &#34;Fm&#34;, 101 : &#34;Md&#34;,
            102 : &#34;No&#34;, 103 : &#34;Lr&#34;, 104 : &#34;Rf&#34;, 105 : &#34;Db&#34;,
            106 : &#34;Sg&#34;, 107 : &#34;Bh&#34;, 108 : &#34;Hs&#34;, 109 : &#34;Mt&#34;,
            110 : &#34;Ds&#34;, 111 : &#34;Rg&#34;, 112 : &#34;Cn&#34;, 113 : &#34;Nh&#34;,
            114 : &#34;Fl&#34;, 115 : &#34;Mc&#34;, 116 : &#34;Lv&#34;, 117 : &#34;Ts&#34;,
            118 : &#34;Og&#34;
            }

        # Create a pymatgen Structure object using the dummy atom positions
        # created earlier
        dummy_structure = pmg.Structure(lattice=self.lattice,
                            species=species_expanded,
                            coords=fractional_expanded)
        i = 0
        for site in dummy_structure:
            for sp in site.species:
                if ((not from_cif) and self.ignore_H_atoms \
                                            and self.absorb_H_Z_increase):
                    zs.append(sp.Z+n_H_connected_expanded[i])
                else:
                    zs.append(sp.Z)
                try:
                    if ((not from_cif)
                        and self.ignore_H_atoms
                        and self.absorb_H_Z_increase):
                        new_Z = sp.Z+n_H_connected_expanded[i]
                        c = ATOMIC_SCATTERING_PARAMS[atomic_numbers[new_Z]]
                    else:
                        c = ATOMIC_SCATTERING_PARAMS[sp.symbol]
                except KeyError as no_key:
                    raise ValueError(&#34;Unable to calculate intensity \
                                    calculation prefix arrays&#34;
                                    &#34;there are no scattering coefficients\
                                    for:&#34; &#34; %s.&#34; % sp.symbol) from no_key
                coeffs.append(c)
                dwfactors.append(debye_waller_factors.get(sp.symbol, 0))
                # DOUBLE CHECK THIS IS CORRECT FOR OCCUPANCY != 1
                occus.append(site[site.specie.symbol])
            i += 1

        zs = np.array(zs)
        coeffs = np.array(coeffs)
        occus = np.array(occus)
        dwfactors = np.array(dwfactors)
        if from_cif:
            self.cif_dwfactors = dwfactors
        else:
            if just_asymmetric:
                self.dwfactors_asymmetric = dwfactors
            else:
                self.dwfactors = dwfactors

        g_hkl = np.sqrt(np.sum(np.dot(self.hkl,
            self.lattice.reciprocal_lattice_crystallographic.matrix)**2,
            axis=1))
        # Note that:
        # d_hkl = 1/g_hkl
        # tt = np.rad2deg(2 * np.arcsin(wavelength / (2*d_hkl)))
        # s = sin(theta) / wavelength = 1 / 2d = |ghkl| / 2 (d = 1/|ghkl|)
        # s = g_hkl / 2
        s2 = (g_hkl / 2)**2

        fs = []
        dw_correction = []
        for x in s2:
            fs.append(zs - 41.78214 * x * np.sum(coeffs[:, :, 0] * \
                                    np.exp(-coeffs[:, :, 1] * x), axis=1))
            dw_correction.append(np.exp(-1*dwfactors * x))
        fs = np.array(fs)
        dw_correction = np.array(dw_correction).astype(float)

        prefix = np.empty_like(fs)
        for i in range(fs.shape[0]):
            for j in range(fs.shape[1]):
                if self.ignore_H_atoms and self.absorb_H_occu_increase:
                    new_occu = ((1 + n_H_connected_expanded[j]) / zs[j])
                    prefix[i][j] = fs[i][j] * occus[j] \
                                            * dw_correction[i][j] \
                                            * new_occu
                else:
                    prefix[i][j] = fs[i][j] * occus[j] * dw_correction[i][j]

        return prefix</code></pre>
</details>
</dd>
<dt id="gallop.structure.Structure.get_affine_matrices"><code class="name flex">
<span>def <span class="ident">get_affine_matrices</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the affine matrices of the space group
Used as a fall-back (generic) method for structure factor
calculation.</p>
<p>GALLOP Structure must have a pymatgen space_group assigned</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy array</code></dt>
<dd>affine matrices for the space group
of shape (n,4,4) where n is the number
of equivalent positions for the space
group.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_affine_matrices(self):
    &#34;&#34;&#34;
    Get the affine matrices of the space group
    Used as a fall-back (generic) method for structure factor
    calculation.

    GALLOP Structure must have a pymatgen space_group assigned

    Returns:
        numpy array:    affine matrices for the space group
                        of shape (n,4,4) where n is the number
                        of equivalent positions for the space
                        group.
    &#34;&#34;&#34;
    affine_matrices = []
    for op in self.space_group.symmetry_ops:
        affine_matrices.append(op.affine_matrix)
    return np.array(affine_matrices)</code></pre>
</details>
</dd>
<dt id="gallop.structure.Structure.get_resolution"><code class="name flex">
<span>def <span class="ident">get_resolution</span></span>(<span>self, twotheta, decimal_places=3)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the d-spacing of a given twotheta value using Bragg's law</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>twotheta</code></strong> :&ensp;<code>float</code></dt>
<dd>The twotheta value of interest</dd>
<dt><strong><code>decimal_places</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of decimal_places to restrict
the result to. Defaults to 3.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>the d-spacing of a twotheta value</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_resolution(self, twotheta, decimal_places=3):
    &#34;&#34;&#34;
    Calculate the d-spacing of a given twotheta value using Bragg&#39;s law

    Args:
        twotheta (float): The twotheta value of interest
        decimal_places (int, optional): Number of decimal_places to restrict
            the result to. Defaults to 3.

    Returns:
        float: the d-spacing of a twotheta value
    &#34;&#34;&#34;
    d = self.wavelength / (2*np.sin(np.deg2rad(twotheta/2)))
    return (np.around(d, decimal_places))</code></pre>
</details>
</dd>
<dt id="gallop.structure.Structure.get_total_degrees_of_freedom"><code class="name flex">
<span>def <span class="ident">get_total_degrees_of_freedom</span></span>(<span>self, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Once all ZMs have been added to the structure object, interrogate them
to determine the total number of degrees of freedom.
This is automatically called by the tensor preparation code, but can
also be called directly to print out the information.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Print out the degrees of freedom.
Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_total_degrees_of_freedom(self, verbose=True):
    &#34;&#34;&#34;
    Once all ZMs have been added to the structure object, interrogate them
    to determine the total number of degrees of freedom.
    This is automatically called by the tensor preparation code, but can
    also be called directly to print out the information.

    Args:
        verbose (bool, optional): Print out the degrees of freedom.
            Defaults to True.
    &#34;&#34;&#34;
    total_dof = 0
    total_external = 0
    total_internal = 0
    total_position = 0
    total_rotation = 0
    for zmat in self.zmatrices:
        total_dof += zmat.degrees_of_freedom
        total_external += zmat.external_degrees_of_freedom
        total_internal += zmat.internal_degrees_of_freedom
        total_position += zmat.position_degrees_of_freedom
        total_rotation += zmat.rotation_degrees_of_freedom
    self.total_degrees_of_freedom = total_dof
    self.total_external_degrees_of_freedom = total_external
    self.total_internal_degrees_of_freedom = total_internal
    self.total_position_degrees_of_freedom = total_position
    self.total_rotation_degrees_of_freedom = total_rotation
    if verbose:
        print(&#34;Total degrees of freedom:&#34;, total_dof)
        print(&#34;Total external degrees of freedom:&#34;, total_external,
            &#34;(pos:&#34;,total_position,&#34;rot:&#34;,total_rotation,&#34;)&#34;)
        print(&#34;Total internal degrees of freedom:&#34;, total_internal)
    zm_torsions = []
    for zmat in self.zmatrices:
        if self.ignore_H_atoms:
            if zmat.internal_degrees_of_freedom &gt; 0:
                idx = zmat.torsion_refineable_indices_no_H
                zm_torsions.append(zmat.coords_radians_no_H[:,2][idx])
        else:
            if zmat.internal_degrees_of_freedom &gt; 0:
                idx = zmat.torsion_refineable_indices
                zm_torsions.append(zmat.coords_radians[:,2][idx])
    if len(zm_torsions) &gt; 0:
        self.zm_torsions = np.hstack(zm_torsions)
    else:
        self.zm_torsions = np.array([])
    self.total_dof_calculated = True</code></pre>
</details>
</dd>
<dt id="gallop.structure.Structure.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self, return_json=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Save a structure object to a JSON formatted string. Can then be used to
instantiate a structure object from a string (or file)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>return_json</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, return a JSON formatted
string, else return a dictionary. Default is True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code> or <code>str</code></dt>
<dd>JSON-compatible dict or JSON formatted string</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self, return_json=True):
    &#34;&#34;&#34;
    Save a structure object to a JSON formatted string. Can then be used to
    instantiate a structure object from a string (or file)

    Args:
        return_json (bool, optional): If True, return a JSON formatted
            string, else return a dictionary. Default is True.

    Returns:
        dict or str: JSON-compatible dict or JSON formatted string
    &#34;&#34;&#34;
    dumpable = {}
    for k, v in self.__dict__.items():
        if k in [&#34;zmatrices&#34;, &#34;lattice&#34;, &#34;space_group&#34;]:
            if k == &#34;zmatrices&#34;:
                dumpable[k] = [zm.to_json(return_json=return_json) for zm in v]
            elif k == &#34;lattice&#34;:
                dumpable[k] = v.as_dict()
        else:
            if isinstance(v, np.ndarray):
                dumpable[k] = [v.tolist(), True]
            elif isinstance(v, np.int32):
                dumpable[k] = [int(v), False]
            else:
                dumpable[k] = [v, False]
    if return_json:
        return json.dumps(dumpable)
    else:
        return dumpable</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gallop" href="index.html">gallop</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gallop.structure.Structure" href="#gallop.structure.Structure">Structure</a></code></h4>
<ul class="">
<li><code><a title="gallop.structure.Structure.add_data" href="#gallop.structure.Structure.add_data">add_data</a></code></li>
<li><code><a title="gallop.structure.Structure.add_zmatrix" href="#gallop.structure.Structure.add_zmatrix">add_zmatrix</a></code></li>
<li><code><a title="gallop.structure.Structure.check_centre_of_symmetry" href="#gallop.structure.Structure.check_centre_of_symmetry">check_centre_of_symmetry</a></code></li>
<li><code><a title="gallop.structure.Structure.from_json" href="#gallop.structure.Structure.from_json">from_json</a></code></li>
<li><code><a title="gallop.structure.Structure.generate_intensity_calculation_prefix" href="#gallop.structure.Structure.generate_intensity_calculation_prefix">generate_intensity_calculation_prefix</a></code></li>
<li><code><a title="gallop.structure.Structure.get_affine_matrices" href="#gallop.structure.Structure.get_affine_matrices">get_affine_matrices</a></code></li>
<li><code><a title="gallop.structure.Structure.get_resolution" href="#gallop.structure.Structure.get_resolution">get_resolution</a></code></li>
<li><code><a title="gallop.structure.Structure.get_total_degrees_of_freedom" href="#gallop.structure.Structure.get_total_degrees_of_freedom">get_total_degrees_of_freedom</a></code></li>
<li><code><a title="gallop.structure.Structure.to_json" href="#gallop.structure.Structure.to_json">to_json</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>