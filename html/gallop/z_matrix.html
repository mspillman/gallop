<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>gallop.z_matrix API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gallop.z_matrix</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
import json

#
# Things to add - extract occupancies from the ZM
#

class Z_matrix(object):
    &#34;&#34;&#34;
    The GALLOP representation of Z-matrices.
    This has convenience methods for reading in DASH Z-matrices, as well as
    a very limited capability to read in gaussian formatted Z-matrices.
    Methods are included to strip out hydrogen atoms, as well as generate
    Cartesian coordinates.

    One common issue that is encountered is when refineable torsion angles are
    defined in terms of hydrogen atoms. This causes the method to remove the H
    atoms to fail.

    A simple fix for this is to:
        1. If not already available, generate a CIF of the structure from which
            the ZMs are being derived.
        2. Reorder the atoms in the CIF such that all non-H atoms come first.
        3. Regenerate the ZMs using makeZmatrix.exe (bundled with DASH)

    The new ZMs will no longer have H-atoms defining torsion angles and should
    not give any errors with this class.
    &#34;&#34;&#34;
    def __init__(self, filename=None, zmformat=&#34;DASH&#34;):
        if filename is not None:
            # Read in the Z-matrix
            self.filename = filename
            if zmformat.lower() == &#34;dash&#34;:
                self.read_DASH_zm(filename)
            elif zmformat.lower() == &#34;gaussian&#34;:
                self.read_Gaussian_zm(filename)
            self.coords_radians = self.zm_angles_to_radians(self.coords)

            # Create a new Z-matrix with no hydrogen atoms
            self.remove_H_from_zm()
            self.coords_radians_no_H=self.zm_angles_to_radians(self.coords_no_H)
            # Zero indexing needed in Python
            self.bond_connection -= 1
            self.angle_connection -= 1
            self.torsion_connection -= 1
            self.bond_connection_no_H -= 1
            self.angle_connection_no_H -= 1
            self.torsion_connection_no_H -= 1
            # Generate some initial Cartesian coordinates for the Z-matrices
            self.initial_cartesian = self.zm_to_cart(self.coords_radians,
                                                self.bond_connection,
                                                self.angle_connection,
                                                self.torsion_connection)
            try:
                self.initial_cartesian_no_H = self.zm_to_cart(
                                                self.coords_radians_no_H,
                                                self.bond_connection_no_H,
                                                self.angle_connection_no_H,
                                                self.torsion_connection_no_H)
                self.H_atom_torsion_defs = False
            except IndexError:
                print(&#34;Error in Z-matrix &#34; + self.filename + \
                &#34;: check to see if refineable torsions are defined in terms of \
                hydrogen atoms in original Z-matrix&#34;)
                print(&#34;All atoms refineable torsions = &#34;,
                                            self.torsion_refineable.sum())
                print(&#34;Non-H atoms refineable torsions = &#34;,
                                            self.torsion_refineable_no_H.sum())
                self.H_atom_torsion_defs = True

            if self.bond_refineable.sum() &gt; 0:
                print(&#34;Refineable bonds not yet supported&#34;)
            if self.angle_refineable.sum() &gt; 0:
                print(&#34;Refineable angles not yet supported&#34;)

            self.get_degrees_of_freedom()

            self.initial_D2      = self.get_initial_D2_for_torch(
                        self.coords_radians, self.torsion_refineable_indices)
            self.initial_D2_no_H = self.get_initial_D2_for_torch(
                self.coords_radians_no_H, self.torsion_refineable_indices_no_H)

    def __repr__(self):
        file_info = &#34;Filename: &#34; + self.filename
        n_non_H_atoms = &#34;\nNon-H atoms: &#34; + str(len(self.elements_no_H))
        n_ref_torsions = &#34;\nRefineable torsions: &#34; + str(np.sum(
                                                    self.torsion_refineable))
        if self.degrees_of_freedom &gt; 3:
            dof = &#34;\nDegrees of freedom: &#34;+str(self.degrees_of_freedom)+\
                            &#34; (7 + &#34;+str(np.sum(self.torsion_refineable))+&#34;)&#34;
        else:
            dof = &#34;\nDegrees of freedom: &#34;+str(self.degrees_of_freedom)

        return file_info + n_non_H_atoms + n_ref_torsions + dof

    def from_json(self, attributes, is_json=True):
        &#34;&#34;&#34;
        Load Z-matrix from a JSON formatted string

        Args:
            attribute_string (str): json string with all attributes of a ZM
        &#34;&#34;&#34;
        if is_json:
            attributes = json.loads(attributes)
        for k, v in attributes.items():
            if v[1]:
                setattr(self, k, np.array(v[0]))
            else:
                setattr(self, k, v[0])

    def to_json(self, return_json=True):
        &#34;&#34;&#34;
        Save the Z-matrix to a JSON formatted string

        Returns:
            str: JSON formatted string of the Z-matrix object attributes
        &#34;&#34;&#34;
        dumpable = {}
        for k, v in self.__dict__.items():
            if isinstance(v, np.ndarray):
                dumpable[k] = [v.tolist(), True]
            elif isinstance(v, np.int32):
                dumpable[k] = [int(v), False]
            else:
                dumpable[k] = [v, False]
        if return_json:
            return json.dumps(dumpable)
        else:
            return dumpable

    def get_degrees_of_freedom(self):
        if len(self.elements) == 1:
            self.degrees_of_freedom = 3
            self.external_degrees_of_freedom = 3
            self.position_degrees_of_freedom = 3
            self.rotation_degrees_of_freedom = 0
            self.internal_degrees_of_freedom = 0
        else:
            self.degrees_of_freedom = 7 + self.torsion_refineable.sum()
            self.external_degrees_of_freedom = 7
            self.position_degrees_of_freedom = 3
            self.rotation_degrees_of_freedom = 4
            self.internal_degrees_of_freedom = self.torsion_refineable.sum()

    #def update_refineable_indices(self):
    #    self.bond_refineable_indices = np.where(self.bond_refineable == 1)[0]
    #    self.angle_refineable_indices = np.where(self.angle_refineable == 1)[0]
    #    self.torsion_refineable_indices = np.where(
    #                                           self.torsion_refineable == 1)[0]
    #    self.remove_H_from_zm()
    #    self.coords_radians_no_H = self.zm_angles_to_radians(self.coords_no_H)

    def read_DASH_zm(self, input_filename):
        &#34;&#34;&#34;
        Read in a DASH Z-matrix

        Args:
            input_filename (string): filename of ZM to read in. Expected to be
            in the current directory, or a properly formatted path.
        &#34;&#34;&#34;
        element = []
        dw_factors = {}
        bond_length, bond_connection, bond_refineable = [], [], []
        angle, angle_connection, angle_refineable = [], [], []
        torsion, torsion_connection, torsion_refineable = [], [], []
        with open(input_filename, &#34;r&#34;) as in_zm:
            i = 0
            for line in in_zm:
                line = list(filter(None, line.strip().split(&#34; &#34;)))
                if i &gt; 2:
                    #if i == 2:
                    #    natoms = int(line[0])
                    #else:
                    element.append(line[0])
                    bond_length.append(line[1])
                    bond_refineable.append(line[2])
                    bond_connection.append(line[7])
                    angle.append(line[3])
                    angle_refineable.append(line[4])
                    angle_connection.append(line[8])
                    torsion.append(line[5])
                    torsion_refineable.append(line[6])
                    torsion_connection.append(line[9])
                    if element[-1] not in dw_factors:
                        dw_factors[element[-1]] = float(line[10])
                i+=1
        in_zm.close()
        bond_length = np.array(bond_length)
        self.bond_connection = np.array(bond_connection).astype(int)
        self.bond_refineable = np.array(bond_refineable).astype(int)

        angle = np.array(angle)
        self.angle_connection = np.array(angle_connection).astype(int)
        self.angle_refineable = np.array(angle_refineable).astype(int)

        torsion = np.array(torsion)
        self.torsion_connection = np.array(torsion_connection).astype(int)
        self.torsion_refineable = np.array(torsion_refineable).astype(int)

        self.coords = np.array([bond_length, angle, torsion]).astype(float).T
        self.elements = element
        self.dw_factors = dw_factors
        self.bond_refineable_indices = np.where(self.bond_refineable == 1)[0]
        self.angle_refineable_indices = np.where(self.angle_refineable == 1)[0]
        self.torsion_refineable_indices = np.where(
                                                self.torsion_refineable == 1)[0]

    def read_Gaussian_zm(self, filename):
        &#34;&#34;&#34;
        This might work, it might not. It&#39;s been tested *very* briefly on how it
        handles rigid bodies, which appears to work fine. However, the Gaussian
        format has no flags to determine which torsion angles are refineable.
        In addition, there may be further issues with the definition of torsions
        where if one of the angles is set to refine, some of the attached atoms
        will rotate and some won&#39;t.
        A Z-matrix constructed with the MakeZmatrix.exe program that is bundled
        with DASH is a *much* better option if it is available.
        &#34;&#34;&#34;
        variables_dict = {}
        zmat = []
        variables = False
        coords = False
        with open(filename, &#34;r&#34;) as infile:
            i = 0
            for line in infile:
                line = list(filter(None, line.strip().split(&#34; &#34;)))
                if len(line) &gt; 0:
                    if len(line) == 1:
                        coords = True
                    if variables:
                        if len(line) &gt; 0:
                            variables_dict[line[0].split(&#34;=&#34;)[0]]=float(line[1])
                    else:
                        if line[0] == &#34;Variables:&#34;:
                            variables = True
                        else:
                            if coords:
                                if len(line) == 7:
                                    zmat.append(line)
                                # Replace the zeros that aren&#39;t needed in
                                # internal coordinates to bring in line with
                                # DASH format
                                else:
                                    temp = []
                                    for j in range(7-len(line)):
                                        if j%2 == 0:
                                            temp.append(&#34;0&#34;)
                                        else:
                                            temp.append(&#34;0.000&#34;)
                                    zmat.append(line+temp)
                i += 1
        # Replace the labels in the zmatrix with the variables
        for i, line in enumerate(zmat):
            for j, item in enumerate(line):
                if item in variables_dict.keys():
                    zmat[i][j] = variables_dict[item]

        self.elements = [row[0] for row in zmat]
        self.bond_connection    = np.array([int(row[1]) for row in zmat])
        self.angle_connection   = np.array([int(row[3]) for row in zmat])
        self.torsion_connection = np.array([int(row[5]) for row in zmat])

        bond    = [float(row[2]) for row in zmat]
        angle   = [float(row[4]) for row in zmat]
        torsion = [float(row[6]) for row in zmat]
        self.coords = np.vstack([bond, angle, torsion]).T

        self.bond_refineable = np.zeros_like(self.bond_connection)
        self.angle_refineable = np.zeros_like(self.angle_connection)
        self.torsion_refineable = np.zeros_like(self.torsion_connection)
        self.dw_factors = {}

        self.bond_refineable_indices = np.where(self.bond_refineable == 1)[0]
        self.angle_refineable_indices = np.where(self.angle_refineable == 1)[0]
        self.torsion_refineable_indices = np.where(
                                                self.torsion_refineable == 1)[0]

    def remove_H_from_zm(self):
        &#34;&#34;&#34;
        Remove hydrogen atoms from the Z-matrix.
        &#34;&#34;&#34;
        coords_no_H, bond_connection_no_H = [], []
        angle_connection_no_H, torsion_connection_no_H = [], []
        bond_refineable_no_H, angle_refineable_no_H = [], []
        torsion_refineable_no_H, elements_no_H = [], []
        old_vs_new_index = []
        n_H_connected = np.zeros_like(self.bond_connection)
        i = 1
        j = 0
        for x in zip(self.elements, self.coords, self.bond_refineable,
                            self.angle_refineable, self.torsion_refineable,
                            self.bond_connection, self.angle_connection,
                                                self.torsion_connection):
            if x[0] != &#34;H&#34;:
                old_vs_new_index.append([i, i-j])
                elements_no_H.append(x[0])
                coords_no_H.append(x[1])
                bond_refineable_no_H.append(x[2])
                angle_refineable_no_H.append(x[3])
                torsion_refineable_no_H.append(x[4])
                bond_connection_no_H.append(x[5])
                angle_connection_no_H.append(x[6])
                torsion_connection_no_H.append(x[7])
            if x[0] == &#34;H&#34;:
                n_H_connected[x[5]] += 1
                j+=1
            i+=1
        old_vs_new_index = np.vstack(old_vs_new_index)
        coords_no_H = np.array(coords_no_H)
        bond_connection_no_H    = np.array(bond_connection_no_H).astype(int)
        angle_connection_no_H   = np.array(angle_connection_no_H).astype(int)
        torsion_connection_no_H = np.array(torsion_connection_no_H).astype(int)
        bond_refineable_no_H    = np.array(bond_refineable_no_H).astype(int)
        angle_refineable_no_H   = np.array(angle_refineable_no_H).astype(int)
        torsion_refineable_no_H = np.array(torsion_refineable_no_H).astype(int)
        n_H_connected = n_H_connected[np.array(self.elements) != &#34;H&#34;]

        for x in old_vs_new_index:
            bond_connection_no_H[bond_connection_no_H == x[0]] = x[1]
            angle_connection_no_H[angle_connection_no_H == x[0]] = x[1]
            torsion_connection_no_H[torsion_connection_no_H == x[0]] = x[1]


        self.coords_no_H = coords_no_H
        self.bond_connection_no_H    = bond_connection_no_H
        self.angle_connection_no_H   = angle_connection_no_H
        self.torsion_connection_no_H = torsion_connection_no_H
        self.bond_refineable_no_H    = bond_refineable_no_H
        self.angle_refineable_no_H   = angle_refineable_no_H
        self.torsion_refineable_no_H = torsion_refineable_no_H
        self.elements_no_H = elements_no_H
        self.n_H_connected = n_H_connected

        self.bond_refineable_indices_no_H = np.where(
                                        self.bond_refineable_no_H == 1)[0]
        self.angle_refineable_indices_no_H = np.where(
                                        self.angle_refineable_no_H == 1)[0]
        self.torsion_refineable_indices_no_H = np.where(
                                        self.torsion_refineable_no_H == 1)[0]


    def zm_angles_to_radians(self, zm):
        &#34;&#34;&#34;
        Convert angles from degrees to radians

        Args:
            zm (numpy array): the Z-matrix coordinates array, shape = n_atoms, 3
                where the second and third columns are bond angles and torsions
                in degrees.

        Returns:
            numpy array: Z-matrix coordinates array, shape = n_atoms, 3
                where the second and third columns are bond angles and torsions
                in radians.
        &#34;&#34;&#34;
        zm_radians = np.copy(zm)
        zm_radians[:,1] = np.deg2rad(zm_radians[:,1])
        zm_radians[:,2] = np.deg2rad(zm_radians[:,2])
        return zm_radians


    def zm_to_cart(self,zm,bond_connection,angle_connection,torsion_connection):
        &#34;&#34;&#34;
        Uses the Natural Extension Reference Frame method to convert from
        Internal to Cartesian coordinates.
        Paper here: https://onlinelibrary.wiley.com/doi/abs/10.1002/jcc.20237
        &#34;&#34;&#34;

        def cross_product(a, b):
            &#34;&#34;&#34;
            Performs the cross-product of two three-dimensional vectors.
            &#34;&#34;&#34;
            return np.array([a[1]*b[2] - a[2]*b[1],
                            a[2]*b[0] - a[0]*b[2],
                            a[0]*b[1] - a[1]*b[0]])

        def get_D2(zm):
            &#34;&#34;&#34;
            Produces the D2 matrix described in the NERF paper linked above.
            &#34;&#34;&#34;
            R = zm[:,0]
            c_t = np.cos(zm[:,1])
            s_t = np.sin(zm[:,1])
            c_p = np.cos(zm[:,2])
            s_p = np.sin(zm[:,2])
            D2 = np.empty((zm.shape[0], 3))
            for i in range(D2.shape[0]):
                D2[i] = R[i] * np.array([-c_t[i], c_p[i]*s_t[i], s_p[i]*s_t[i]])
            return D2

        def normalize(vector):
            &#34;&#34;&#34;
            Normalize a vector
            &#34;&#34;&#34;
            return vector / np.sqrt(np.dot(vector, vector))

        D2 = get_D2(zm)
        cart = np.zeros_like(D2)
        cart[0:3] = D2[0:3]
        for i in range(3, zm.shape[0]):
            C = cart[bond_connection[i]]
            B = cart[angle_connection[i]]
            A = cart[torsion_connection[i]]
            bc = normalize(C - B)
            AB = B - A
            n = normalize(cross_product(AB, bc))
            n_bc = cross_product(n, bc)
            M = np.vstack((bc, n_bc, n))
            cart[i] = np.dot(M.T, D2[i]) + C
        return cart

    def get_initial_D2_for_torch(self, zm, ref):
        &#34;&#34;&#34;
        Used by PyTorch based SDPD for converting internal to external coords.
        The idea is that the NeRF method of internal -&gt; Cartesian uses a D2
        matrix. The elements of this matrix can be modified to accommodate
        changes in the molecule such as torsion angles, bond angles or bond
        lengths.

        Currently, only the torsion angles are refineable, and therefore the
        rest of the D2 matrix is static. All that needs to be done is to
        generate the matrix as normal (see paper for details) and then multiply
        the relevant elements by the torsion angles.

        To accomplish this, generate the D2 matrix, then divide the relevant
        elements by the existing refineable torsion angle values.

        Args:
            zm (numpy array): the molecular z-matrix
            ref (numpy array): The indices of the refineable torsion angles

        Returns:
            numpy array: D2 matrix, with the elements that rely on the
                        refineable torsion angles divided by the initial torsion
                        angles, to speed up internal -&gt; Cartesian conversion.
        &#34;&#34;&#34;

        R = zm[:,0] # lengths
        c_t = np.cos(zm[:,1]) # angles
        s_t = np.sin(zm[:,1])
        c_p = np.cos(zm[:,2]) # torsions
        s_p = np.sin(zm[:,2])
        D2 = np.empty((zm.shape[0], 3))
        for i in range(D2.shape[0]):
            D2[i] = R[i] * np.array([-c_t[i], c_p[i]*s_t[i], s_p[i]*s_t[i]])
        D2[:,1][ref] = D2[:,1][ref] / c_p[ref]
        D2[:,2][ref] = D2[:,2][ref] / s_p[ref]
        return D2</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="gallop.z_matrix.Z_matrix"><code class="flex name class">
<span>class <span class="ident">Z_matrix</span></span>
<span>(</span><span>filename=None, zmformat='DASH')</span>
</code></dt>
<dd>
<div class="desc"><p>The GALLOP representation of Z-matrices.
This has convenience methods for reading in DASH Z-matrices, as well as
a very limited capability to read in gaussian formatted Z-matrices.
Methods are included to strip out hydrogen atoms, as well as generate
Cartesian coordinates.</p>
<p>One common issue that is encountered is when refineable torsion angles are
defined in terms of hydrogen atoms. This causes the method to remove the H
atoms to fail.</p>
<p>A simple fix for this is to:
1. If not already available, generate a CIF of the structure from which
the ZMs are being derived.
2. Reorder the atoms in the CIF such that all non-H atoms come first.
3. Regenerate the ZMs using makeZmatrix.exe (bundled with DASH)</p>
<p>The new ZMs will no longer have H-atoms defining torsion angles and should
not give any errors with this class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Z_matrix(object):
    &#34;&#34;&#34;
    The GALLOP representation of Z-matrices.
    This has convenience methods for reading in DASH Z-matrices, as well as
    a very limited capability to read in gaussian formatted Z-matrices.
    Methods are included to strip out hydrogen atoms, as well as generate
    Cartesian coordinates.

    One common issue that is encountered is when refineable torsion angles are
    defined in terms of hydrogen atoms. This causes the method to remove the H
    atoms to fail.

    A simple fix for this is to:
        1. If not already available, generate a CIF of the structure from which
            the ZMs are being derived.
        2. Reorder the atoms in the CIF such that all non-H atoms come first.
        3. Regenerate the ZMs using makeZmatrix.exe (bundled with DASH)

    The new ZMs will no longer have H-atoms defining torsion angles and should
    not give any errors with this class.
    &#34;&#34;&#34;
    def __init__(self, filename=None, zmformat=&#34;DASH&#34;):
        if filename is not None:
            # Read in the Z-matrix
            self.filename = filename
            if zmformat.lower() == &#34;dash&#34;:
                self.read_DASH_zm(filename)
            elif zmformat.lower() == &#34;gaussian&#34;:
                self.read_Gaussian_zm(filename)
            self.coords_radians = self.zm_angles_to_radians(self.coords)

            # Create a new Z-matrix with no hydrogen atoms
            self.remove_H_from_zm()
            self.coords_radians_no_H=self.zm_angles_to_radians(self.coords_no_H)
            # Zero indexing needed in Python
            self.bond_connection -= 1
            self.angle_connection -= 1
            self.torsion_connection -= 1
            self.bond_connection_no_H -= 1
            self.angle_connection_no_H -= 1
            self.torsion_connection_no_H -= 1
            # Generate some initial Cartesian coordinates for the Z-matrices
            self.initial_cartesian = self.zm_to_cart(self.coords_radians,
                                                self.bond_connection,
                                                self.angle_connection,
                                                self.torsion_connection)
            try:
                self.initial_cartesian_no_H = self.zm_to_cart(
                                                self.coords_radians_no_H,
                                                self.bond_connection_no_H,
                                                self.angle_connection_no_H,
                                                self.torsion_connection_no_H)
                self.H_atom_torsion_defs = False
            except IndexError:
                print(&#34;Error in Z-matrix &#34; + self.filename + \
                &#34;: check to see if refineable torsions are defined in terms of \
                hydrogen atoms in original Z-matrix&#34;)
                print(&#34;All atoms refineable torsions = &#34;,
                                            self.torsion_refineable.sum())
                print(&#34;Non-H atoms refineable torsions = &#34;,
                                            self.torsion_refineable_no_H.sum())
                self.H_atom_torsion_defs = True

            if self.bond_refineable.sum() &gt; 0:
                print(&#34;Refineable bonds not yet supported&#34;)
            if self.angle_refineable.sum() &gt; 0:
                print(&#34;Refineable angles not yet supported&#34;)

            self.get_degrees_of_freedom()

            self.initial_D2      = self.get_initial_D2_for_torch(
                        self.coords_radians, self.torsion_refineable_indices)
            self.initial_D2_no_H = self.get_initial_D2_for_torch(
                self.coords_radians_no_H, self.torsion_refineable_indices_no_H)

    def __repr__(self):
        file_info = &#34;Filename: &#34; + self.filename
        n_non_H_atoms = &#34;\nNon-H atoms: &#34; + str(len(self.elements_no_H))
        n_ref_torsions = &#34;\nRefineable torsions: &#34; + str(np.sum(
                                                    self.torsion_refineable))
        if self.degrees_of_freedom &gt; 3:
            dof = &#34;\nDegrees of freedom: &#34;+str(self.degrees_of_freedom)+\
                            &#34; (7 + &#34;+str(np.sum(self.torsion_refineable))+&#34;)&#34;
        else:
            dof = &#34;\nDegrees of freedom: &#34;+str(self.degrees_of_freedom)

        return file_info + n_non_H_atoms + n_ref_torsions + dof

    def from_json(self, attributes, is_json=True):
        &#34;&#34;&#34;
        Load Z-matrix from a JSON formatted string

        Args:
            attribute_string (str): json string with all attributes of a ZM
        &#34;&#34;&#34;
        if is_json:
            attributes = json.loads(attributes)
        for k, v in attributes.items():
            if v[1]:
                setattr(self, k, np.array(v[0]))
            else:
                setattr(self, k, v[0])

    def to_json(self, return_json=True):
        &#34;&#34;&#34;
        Save the Z-matrix to a JSON formatted string

        Returns:
            str: JSON formatted string of the Z-matrix object attributes
        &#34;&#34;&#34;
        dumpable = {}
        for k, v in self.__dict__.items():
            if isinstance(v, np.ndarray):
                dumpable[k] = [v.tolist(), True]
            elif isinstance(v, np.int32):
                dumpable[k] = [int(v), False]
            else:
                dumpable[k] = [v, False]
        if return_json:
            return json.dumps(dumpable)
        else:
            return dumpable

    def get_degrees_of_freedom(self):
        if len(self.elements) == 1:
            self.degrees_of_freedom = 3
            self.external_degrees_of_freedom = 3
            self.position_degrees_of_freedom = 3
            self.rotation_degrees_of_freedom = 0
            self.internal_degrees_of_freedom = 0
        else:
            self.degrees_of_freedom = 7 + self.torsion_refineable.sum()
            self.external_degrees_of_freedom = 7
            self.position_degrees_of_freedom = 3
            self.rotation_degrees_of_freedom = 4
            self.internal_degrees_of_freedom = self.torsion_refineable.sum()

    #def update_refineable_indices(self):
    #    self.bond_refineable_indices = np.where(self.bond_refineable == 1)[0]
    #    self.angle_refineable_indices = np.where(self.angle_refineable == 1)[0]
    #    self.torsion_refineable_indices = np.where(
    #                                           self.torsion_refineable == 1)[0]
    #    self.remove_H_from_zm()
    #    self.coords_radians_no_H = self.zm_angles_to_radians(self.coords_no_H)

    def read_DASH_zm(self, input_filename):
        &#34;&#34;&#34;
        Read in a DASH Z-matrix

        Args:
            input_filename (string): filename of ZM to read in. Expected to be
            in the current directory, or a properly formatted path.
        &#34;&#34;&#34;
        element = []
        dw_factors = {}
        bond_length, bond_connection, bond_refineable = [], [], []
        angle, angle_connection, angle_refineable = [], [], []
        torsion, torsion_connection, torsion_refineable = [], [], []
        with open(input_filename, &#34;r&#34;) as in_zm:
            i = 0
            for line in in_zm:
                line = list(filter(None, line.strip().split(&#34; &#34;)))
                if i &gt; 2:
                    #if i == 2:
                    #    natoms = int(line[0])
                    #else:
                    element.append(line[0])
                    bond_length.append(line[1])
                    bond_refineable.append(line[2])
                    bond_connection.append(line[7])
                    angle.append(line[3])
                    angle_refineable.append(line[4])
                    angle_connection.append(line[8])
                    torsion.append(line[5])
                    torsion_refineable.append(line[6])
                    torsion_connection.append(line[9])
                    if element[-1] not in dw_factors:
                        dw_factors[element[-1]] = float(line[10])
                i+=1
        in_zm.close()
        bond_length = np.array(bond_length)
        self.bond_connection = np.array(bond_connection).astype(int)
        self.bond_refineable = np.array(bond_refineable).astype(int)

        angle = np.array(angle)
        self.angle_connection = np.array(angle_connection).astype(int)
        self.angle_refineable = np.array(angle_refineable).astype(int)

        torsion = np.array(torsion)
        self.torsion_connection = np.array(torsion_connection).astype(int)
        self.torsion_refineable = np.array(torsion_refineable).astype(int)

        self.coords = np.array([bond_length, angle, torsion]).astype(float).T
        self.elements = element
        self.dw_factors = dw_factors
        self.bond_refineable_indices = np.where(self.bond_refineable == 1)[0]
        self.angle_refineable_indices = np.where(self.angle_refineable == 1)[0]
        self.torsion_refineable_indices = np.where(
                                                self.torsion_refineable == 1)[0]

    def read_Gaussian_zm(self, filename):
        &#34;&#34;&#34;
        This might work, it might not. It&#39;s been tested *very* briefly on how it
        handles rigid bodies, which appears to work fine. However, the Gaussian
        format has no flags to determine which torsion angles are refineable.
        In addition, there may be further issues with the definition of torsions
        where if one of the angles is set to refine, some of the attached atoms
        will rotate and some won&#39;t.
        A Z-matrix constructed with the MakeZmatrix.exe program that is bundled
        with DASH is a *much* better option if it is available.
        &#34;&#34;&#34;
        variables_dict = {}
        zmat = []
        variables = False
        coords = False
        with open(filename, &#34;r&#34;) as infile:
            i = 0
            for line in infile:
                line = list(filter(None, line.strip().split(&#34; &#34;)))
                if len(line) &gt; 0:
                    if len(line) == 1:
                        coords = True
                    if variables:
                        if len(line) &gt; 0:
                            variables_dict[line[0].split(&#34;=&#34;)[0]]=float(line[1])
                    else:
                        if line[0] == &#34;Variables:&#34;:
                            variables = True
                        else:
                            if coords:
                                if len(line) == 7:
                                    zmat.append(line)
                                # Replace the zeros that aren&#39;t needed in
                                # internal coordinates to bring in line with
                                # DASH format
                                else:
                                    temp = []
                                    for j in range(7-len(line)):
                                        if j%2 == 0:
                                            temp.append(&#34;0&#34;)
                                        else:
                                            temp.append(&#34;0.000&#34;)
                                    zmat.append(line+temp)
                i += 1
        # Replace the labels in the zmatrix with the variables
        for i, line in enumerate(zmat):
            for j, item in enumerate(line):
                if item in variables_dict.keys():
                    zmat[i][j] = variables_dict[item]

        self.elements = [row[0] for row in zmat]
        self.bond_connection    = np.array([int(row[1]) for row in zmat])
        self.angle_connection   = np.array([int(row[3]) for row in zmat])
        self.torsion_connection = np.array([int(row[5]) for row in zmat])

        bond    = [float(row[2]) for row in zmat]
        angle   = [float(row[4]) for row in zmat]
        torsion = [float(row[6]) for row in zmat]
        self.coords = np.vstack([bond, angle, torsion]).T

        self.bond_refineable = np.zeros_like(self.bond_connection)
        self.angle_refineable = np.zeros_like(self.angle_connection)
        self.torsion_refineable = np.zeros_like(self.torsion_connection)
        self.dw_factors = {}

        self.bond_refineable_indices = np.where(self.bond_refineable == 1)[0]
        self.angle_refineable_indices = np.where(self.angle_refineable == 1)[0]
        self.torsion_refineable_indices = np.where(
                                                self.torsion_refineable == 1)[0]

    def remove_H_from_zm(self):
        &#34;&#34;&#34;
        Remove hydrogen atoms from the Z-matrix.
        &#34;&#34;&#34;
        coords_no_H, bond_connection_no_H = [], []
        angle_connection_no_H, torsion_connection_no_H = [], []
        bond_refineable_no_H, angle_refineable_no_H = [], []
        torsion_refineable_no_H, elements_no_H = [], []
        old_vs_new_index = []
        n_H_connected = np.zeros_like(self.bond_connection)
        i = 1
        j = 0
        for x in zip(self.elements, self.coords, self.bond_refineable,
                            self.angle_refineable, self.torsion_refineable,
                            self.bond_connection, self.angle_connection,
                                                self.torsion_connection):
            if x[0] != &#34;H&#34;:
                old_vs_new_index.append([i, i-j])
                elements_no_H.append(x[0])
                coords_no_H.append(x[1])
                bond_refineable_no_H.append(x[2])
                angle_refineable_no_H.append(x[3])
                torsion_refineable_no_H.append(x[4])
                bond_connection_no_H.append(x[5])
                angle_connection_no_H.append(x[6])
                torsion_connection_no_H.append(x[7])
            if x[0] == &#34;H&#34;:
                n_H_connected[x[5]] += 1
                j+=1
            i+=1
        old_vs_new_index = np.vstack(old_vs_new_index)
        coords_no_H = np.array(coords_no_H)
        bond_connection_no_H    = np.array(bond_connection_no_H).astype(int)
        angle_connection_no_H   = np.array(angle_connection_no_H).astype(int)
        torsion_connection_no_H = np.array(torsion_connection_no_H).astype(int)
        bond_refineable_no_H    = np.array(bond_refineable_no_H).astype(int)
        angle_refineable_no_H   = np.array(angle_refineable_no_H).astype(int)
        torsion_refineable_no_H = np.array(torsion_refineable_no_H).astype(int)
        n_H_connected = n_H_connected[np.array(self.elements) != &#34;H&#34;]

        for x in old_vs_new_index:
            bond_connection_no_H[bond_connection_no_H == x[0]] = x[1]
            angle_connection_no_H[angle_connection_no_H == x[0]] = x[1]
            torsion_connection_no_H[torsion_connection_no_H == x[0]] = x[1]


        self.coords_no_H = coords_no_H
        self.bond_connection_no_H    = bond_connection_no_H
        self.angle_connection_no_H   = angle_connection_no_H
        self.torsion_connection_no_H = torsion_connection_no_H
        self.bond_refineable_no_H    = bond_refineable_no_H
        self.angle_refineable_no_H   = angle_refineable_no_H
        self.torsion_refineable_no_H = torsion_refineable_no_H
        self.elements_no_H = elements_no_H
        self.n_H_connected = n_H_connected

        self.bond_refineable_indices_no_H = np.where(
                                        self.bond_refineable_no_H == 1)[0]
        self.angle_refineable_indices_no_H = np.where(
                                        self.angle_refineable_no_H == 1)[0]
        self.torsion_refineable_indices_no_H = np.where(
                                        self.torsion_refineable_no_H == 1)[0]


    def zm_angles_to_radians(self, zm):
        &#34;&#34;&#34;
        Convert angles from degrees to radians

        Args:
            zm (numpy array): the Z-matrix coordinates array, shape = n_atoms, 3
                where the second and third columns are bond angles and torsions
                in degrees.

        Returns:
            numpy array: Z-matrix coordinates array, shape = n_atoms, 3
                where the second and third columns are bond angles and torsions
                in radians.
        &#34;&#34;&#34;
        zm_radians = np.copy(zm)
        zm_radians[:,1] = np.deg2rad(zm_radians[:,1])
        zm_radians[:,2] = np.deg2rad(zm_radians[:,2])
        return zm_radians


    def zm_to_cart(self,zm,bond_connection,angle_connection,torsion_connection):
        &#34;&#34;&#34;
        Uses the Natural Extension Reference Frame method to convert from
        Internal to Cartesian coordinates.
        Paper here: https://onlinelibrary.wiley.com/doi/abs/10.1002/jcc.20237
        &#34;&#34;&#34;

        def cross_product(a, b):
            &#34;&#34;&#34;
            Performs the cross-product of two three-dimensional vectors.
            &#34;&#34;&#34;
            return np.array([a[1]*b[2] - a[2]*b[1],
                            a[2]*b[0] - a[0]*b[2],
                            a[0]*b[1] - a[1]*b[0]])

        def get_D2(zm):
            &#34;&#34;&#34;
            Produces the D2 matrix described in the NERF paper linked above.
            &#34;&#34;&#34;
            R = zm[:,0]
            c_t = np.cos(zm[:,1])
            s_t = np.sin(zm[:,1])
            c_p = np.cos(zm[:,2])
            s_p = np.sin(zm[:,2])
            D2 = np.empty((zm.shape[0], 3))
            for i in range(D2.shape[0]):
                D2[i] = R[i] * np.array([-c_t[i], c_p[i]*s_t[i], s_p[i]*s_t[i]])
            return D2

        def normalize(vector):
            &#34;&#34;&#34;
            Normalize a vector
            &#34;&#34;&#34;
            return vector / np.sqrt(np.dot(vector, vector))

        D2 = get_D2(zm)
        cart = np.zeros_like(D2)
        cart[0:3] = D2[0:3]
        for i in range(3, zm.shape[0]):
            C = cart[bond_connection[i]]
            B = cart[angle_connection[i]]
            A = cart[torsion_connection[i]]
            bc = normalize(C - B)
            AB = B - A
            n = normalize(cross_product(AB, bc))
            n_bc = cross_product(n, bc)
            M = np.vstack((bc, n_bc, n))
            cart[i] = np.dot(M.T, D2[i]) + C
        return cart

    def get_initial_D2_for_torch(self, zm, ref):
        &#34;&#34;&#34;
        Used by PyTorch based SDPD for converting internal to external coords.
        The idea is that the NeRF method of internal -&gt; Cartesian uses a D2
        matrix. The elements of this matrix can be modified to accommodate
        changes in the molecule such as torsion angles, bond angles or bond
        lengths.

        Currently, only the torsion angles are refineable, and therefore the
        rest of the D2 matrix is static. All that needs to be done is to
        generate the matrix as normal (see paper for details) and then multiply
        the relevant elements by the torsion angles.

        To accomplish this, generate the D2 matrix, then divide the relevant
        elements by the existing refineable torsion angle values.

        Args:
            zm (numpy array): the molecular z-matrix
            ref (numpy array): The indices of the refineable torsion angles

        Returns:
            numpy array: D2 matrix, with the elements that rely on the
                        refineable torsion angles divided by the initial torsion
                        angles, to speed up internal -&gt; Cartesian conversion.
        &#34;&#34;&#34;

        R = zm[:,0] # lengths
        c_t = np.cos(zm[:,1]) # angles
        s_t = np.sin(zm[:,1])
        c_p = np.cos(zm[:,2]) # torsions
        s_p = np.sin(zm[:,2])
        D2 = np.empty((zm.shape[0], 3))
        for i in range(D2.shape[0]):
            D2[i] = R[i] * np.array([-c_t[i], c_p[i]*s_t[i], s_p[i]*s_t[i]])
        D2[:,1][ref] = D2[:,1][ref] / c_p[ref]
        D2[:,2][ref] = D2[:,2][ref] / s_p[ref]
        return D2</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="gallop.z_matrix.Z_matrix.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>self, attributes, is_json=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Load Z-matrix from a JSON formatted string</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>attribute_string</code></strong> :&ensp;<code>str</code></dt>
<dd>json string with all attributes of a ZM</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_json(self, attributes, is_json=True):
    &#34;&#34;&#34;
    Load Z-matrix from a JSON formatted string

    Args:
        attribute_string (str): json string with all attributes of a ZM
    &#34;&#34;&#34;
    if is_json:
        attributes = json.loads(attributes)
    for k, v in attributes.items():
        if v[1]:
            setattr(self, k, np.array(v[0]))
        else:
            setattr(self, k, v[0])</code></pre>
</details>
</dd>
<dt id="gallop.z_matrix.Z_matrix.get_degrees_of_freedom"><code class="name flex">
<span>def <span class="ident">get_degrees_of_freedom</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_degrees_of_freedom(self):
    if len(self.elements) == 1:
        self.degrees_of_freedom = 3
        self.external_degrees_of_freedom = 3
        self.position_degrees_of_freedom = 3
        self.rotation_degrees_of_freedom = 0
        self.internal_degrees_of_freedom = 0
    else:
        self.degrees_of_freedom = 7 + self.torsion_refineable.sum()
        self.external_degrees_of_freedom = 7
        self.position_degrees_of_freedom = 3
        self.rotation_degrees_of_freedom = 4
        self.internal_degrees_of_freedom = self.torsion_refineable.sum()</code></pre>
</details>
</dd>
<dt id="gallop.z_matrix.Z_matrix.get_initial_D2_for_torch"><code class="name flex">
<span>def <span class="ident">get_initial_D2_for_torch</span></span>(<span>self, zm, ref)</span>
</code></dt>
<dd>
<div class="desc"><p>Used by PyTorch based SDPD for converting internal to external coords.
The idea is that the NeRF method of internal -&gt; Cartesian uses a D2
matrix. The elements of this matrix can be modified to accommodate
changes in the molecule such as torsion angles, bond angles or bond
lengths.</p>
<p>Currently, only the torsion angles are refineable, and therefore the
rest of the D2 matrix is static. All that needs to be done is to
generate the matrix as normal (see paper for details) and then multiply
the relevant elements by the torsion angles.</p>
<p>To accomplish this, generate the D2 matrix, then divide the relevant
elements by the existing refineable torsion angle values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>zm</code></strong> :&ensp;<code>numpy array</code></dt>
<dd>the molecular z-matrix</dd>
<dt><strong><code>ref</code></strong> :&ensp;<code>numpy array</code></dt>
<dd>The indices of the refineable torsion angles</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy array</code></dt>
<dd>D2 matrix, with the elements that rely on the
refineable torsion angles divided by the initial torsion
angles, to speed up internal -&gt; Cartesian conversion.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_initial_D2_for_torch(self, zm, ref):
    &#34;&#34;&#34;
    Used by PyTorch based SDPD for converting internal to external coords.
    The idea is that the NeRF method of internal -&gt; Cartesian uses a D2
    matrix. The elements of this matrix can be modified to accommodate
    changes in the molecule such as torsion angles, bond angles or bond
    lengths.

    Currently, only the torsion angles are refineable, and therefore the
    rest of the D2 matrix is static. All that needs to be done is to
    generate the matrix as normal (see paper for details) and then multiply
    the relevant elements by the torsion angles.

    To accomplish this, generate the D2 matrix, then divide the relevant
    elements by the existing refineable torsion angle values.

    Args:
        zm (numpy array): the molecular z-matrix
        ref (numpy array): The indices of the refineable torsion angles

    Returns:
        numpy array: D2 matrix, with the elements that rely on the
                    refineable torsion angles divided by the initial torsion
                    angles, to speed up internal -&gt; Cartesian conversion.
    &#34;&#34;&#34;

    R = zm[:,0] # lengths
    c_t = np.cos(zm[:,1]) # angles
    s_t = np.sin(zm[:,1])
    c_p = np.cos(zm[:,2]) # torsions
    s_p = np.sin(zm[:,2])
    D2 = np.empty((zm.shape[0], 3))
    for i in range(D2.shape[0]):
        D2[i] = R[i] * np.array([-c_t[i], c_p[i]*s_t[i], s_p[i]*s_t[i]])
    D2[:,1][ref] = D2[:,1][ref] / c_p[ref]
    D2[:,2][ref] = D2[:,2][ref] / s_p[ref]
    return D2</code></pre>
</details>
</dd>
<dt id="gallop.z_matrix.Z_matrix.read_DASH_zm"><code class="name flex">
<span>def <span class="ident">read_DASH_zm</span></span>(<span>self, input_filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Read in a DASH Z-matrix</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_filename</code></strong> :&ensp;<code>string</code></dt>
<dd>filename of ZM to read in. Expected to be</dd>
</dl>
<p>in the current directory, or a properly formatted path.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_DASH_zm(self, input_filename):
    &#34;&#34;&#34;
    Read in a DASH Z-matrix

    Args:
        input_filename (string): filename of ZM to read in. Expected to be
        in the current directory, or a properly formatted path.
    &#34;&#34;&#34;
    element = []
    dw_factors = {}
    bond_length, bond_connection, bond_refineable = [], [], []
    angle, angle_connection, angle_refineable = [], [], []
    torsion, torsion_connection, torsion_refineable = [], [], []
    with open(input_filename, &#34;r&#34;) as in_zm:
        i = 0
        for line in in_zm:
            line = list(filter(None, line.strip().split(&#34; &#34;)))
            if i &gt; 2:
                #if i == 2:
                #    natoms = int(line[0])
                #else:
                element.append(line[0])
                bond_length.append(line[1])
                bond_refineable.append(line[2])
                bond_connection.append(line[7])
                angle.append(line[3])
                angle_refineable.append(line[4])
                angle_connection.append(line[8])
                torsion.append(line[5])
                torsion_refineable.append(line[6])
                torsion_connection.append(line[9])
                if element[-1] not in dw_factors:
                    dw_factors[element[-1]] = float(line[10])
            i+=1
    in_zm.close()
    bond_length = np.array(bond_length)
    self.bond_connection = np.array(bond_connection).astype(int)
    self.bond_refineable = np.array(bond_refineable).astype(int)

    angle = np.array(angle)
    self.angle_connection = np.array(angle_connection).astype(int)
    self.angle_refineable = np.array(angle_refineable).astype(int)

    torsion = np.array(torsion)
    self.torsion_connection = np.array(torsion_connection).astype(int)
    self.torsion_refineable = np.array(torsion_refineable).astype(int)

    self.coords = np.array([bond_length, angle, torsion]).astype(float).T
    self.elements = element
    self.dw_factors = dw_factors
    self.bond_refineable_indices = np.where(self.bond_refineable == 1)[0]
    self.angle_refineable_indices = np.where(self.angle_refineable == 1)[0]
    self.torsion_refineable_indices = np.where(
                                            self.torsion_refineable == 1)[0]</code></pre>
</details>
</dd>
<dt id="gallop.z_matrix.Z_matrix.read_Gaussian_zm"><code class="name flex">
<span>def <span class="ident">read_Gaussian_zm</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>This might work, it might not. It's been tested <em>very</em> briefly on how it
handles rigid bodies, which appears to work fine. However, the Gaussian
format has no flags to determine which torsion angles are refineable.
In addition, there may be further issues with the definition of torsions
where if one of the angles is set to refine, some of the attached atoms
will rotate and some won't.
A Z-matrix constructed with the MakeZmatrix.exe program that is bundled
with DASH is a <em>much</em> better option if it is available.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_Gaussian_zm(self, filename):
    &#34;&#34;&#34;
    This might work, it might not. It&#39;s been tested *very* briefly on how it
    handles rigid bodies, which appears to work fine. However, the Gaussian
    format has no flags to determine which torsion angles are refineable.
    In addition, there may be further issues with the definition of torsions
    where if one of the angles is set to refine, some of the attached atoms
    will rotate and some won&#39;t.
    A Z-matrix constructed with the MakeZmatrix.exe program that is bundled
    with DASH is a *much* better option if it is available.
    &#34;&#34;&#34;
    variables_dict = {}
    zmat = []
    variables = False
    coords = False
    with open(filename, &#34;r&#34;) as infile:
        i = 0
        for line in infile:
            line = list(filter(None, line.strip().split(&#34; &#34;)))
            if len(line) &gt; 0:
                if len(line) == 1:
                    coords = True
                if variables:
                    if len(line) &gt; 0:
                        variables_dict[line[0].split(&#34;=&#34;)[0]]=float(line[1])
                else:
                    if line[0] == &#34;Variables:&#34;:
                        variables = True
                    else:
                        if coords:
                            if len(line) == 7:
                                zmat.append(line)
                            # Replace the zeros that aren&#39;t needed in
                            # internal coordinates to bring in line with
                            # DASH format
                            else:
                                temp = []
                                for j in range(7-len(line)):
                                    if j%2 == 0:
                                        temp.append(&#34;0&#34;)
                                    else:
                                        temp.append(&#34;0.000&#34;)
                                zmat.append(line+temp)
            i += 1
    # Replace the labels in the zmatrix with the variables
    for i, line in enumerate(zmat):
        for j, item in enumerate(line):
            if item in variables_dict.keys():
                zmat[i][j] = variables_dict[item]

    self.elements = [row[0] for row in zmat]
    self.bond_connection    = np.array([int(row[1]) for row in zmat])
    self.angle_connection   = np.array([int(row[3]) for row in zmat])
    self.torsion_connection = np.array([int(row[5]) for row in zmat])

    bond    = [float(row[2]) for row in zmat]
    angle   = [float(row[4]) for row in zmat]
    torsion = [float(row[6]) for row in zmat]
    self.coords = np.vstack([bond, angle, torsion]).T

    self.bond_refineable = np.zeros_like(self.bond_connection)
    self.angle_refineable = np.zeros_like(self.angle_connection)
    self.torsion_refineable = np.zeros_like(self.torsion_connection)
    self.dw_factors = {}

    self.bond_refineable_indices = np.where(self.bond_refineable == 1)[0]
    self.angle_refineable_indices = np.where(self.angle_refineable == 1)[0]
    self.torsion_refineable_indices = np.where(
                                            self.torsion_refineable == 1)[0]</code></pre>
</details>
</dd>
<dt id="gallop.z_matrix.Z_matrix.remove_H_from_zm"><code class="name flex">
<span>def <span class="ident">remove_H_from_zm</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove hydrogen atoms from the Z-matrix.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_H_from_zm(self):
    &#34;&#34;&#34;
    Remove hydrogen atoms from the Z-matrix.
    &#34;&#34;&#34;
    coords_no_H, bond_connection_no_H = [], []
    angle_connection_no_H, torsion_connection_no_H = [], []
    bond_refineable_no_H, angle_refineable_no_H = [], []
    torsion_refineable_no_H, elements_no_H = [], []
    old_vs_new_index = []
    n_H_connected = np.zeros_like(self.bond_connection)
    i = 1
    j = 0
    for x in zip(self.elements, self.coords, self.bond_refineable,
                        self.angle_refineable, self.torsion_refineable,
                        self.bond_connection, self.angle_connection,
                                            self.torsion_connection):
        if x[0] != &#34;H&#34;:
            old_vs_new_index.append([i, i-j])
            elements_no_H.append(x[0])
            coords_no_H.append(x[1])
            bond_refineable_no_H.append(x[2])
            angle_refineable_no_H.append(x[3])
            torsion_refineable_no_H.append(x[4])
            bond_connection_no_H.append(x[5])
            angle_connection_no_H.append(x[6])
            torsion_connection_no_H.append(x[7])
        if x[0] == &#34;H&#34;:
            n_H_connected[x[5]] += 1
            j+=1
        i+=1
    old_vs_new_index = np.vstack(old_vs_new_index)
    coords_no_H = np.array(coords_no_H)
    bond_connection_no_H    = np.array(bond_connection_no_H).astype(int)
    angle_connection_no_H   = np.array(angle_connection_no_H).astype(int)
    torsion_connection_no_H = np.array(torsion_connection_no_H).astype(int)
    bond_refineable_no_H    = np.array(bond_refineable_no_H).astype(int)
    angle_refineable_no_H   = np.array(angle_refineable_no_H).astype(int)
    torsion_refineable_no_H = np.array(torsion_refineable_no_H).astype(int)
    n_H_connected = n_H_connected[np.array(self.elements) != &#34;H&#34;]

    for x in old_vs_new_index:
        bond_connection_no_H[bond_connection_no_H == x[0]] = x[1]
        angle_connection_no_H[angle_connection_no_H == x[0]] = x[1]
        torsion_connection_no_H[torsion_connection_no_H == x[0]] = x[1]


    self.coords_no_H = coords_no_H
    self.bond_connection_no_H    = bond_connection_no_H
    self.angle_connection_no_H   = angle_connection_no_H
    self.torsion_connection_no_H = torsion_connection_no_H
    self.bond_refineable_no_H    = bond_refineable_no_H
    self.angle_refineable_no_H   = angle_refineable_no_H
    self.torsion_refineable_no_H = torsion_refineable_no_H
    self.elements_no_H = elements_no_H
    self.n_H_connected = n_H_connected

    self.bond_refineable_indices_no_H = np.where(
                                    self.bond_refineable_no_H == 1)[0]
    self.angle_refineable_indices_no_H = np.where(
                                    self.angle_refineable_no_H == 1)[0]
    self.torsion_refineable_indices_no_H = np.where(
                                    self.torsion_refineable_no_H == 1)[0]</code></pre>
</details>
</dd>
<dt id="gallop.z_matrix.Z_matrix.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self, return_json=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the Z-matrix to a JSON formatted string</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>JSON formatted string of the Z-matrix object attributes</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self, return_json=True):
    &#34;&#34;&#34;
    Save the Z-matrix to a JSON formatted string

    Returns:
        str: JSON formatted string of the Z-matrix object attributes
    &#34;&#34;&#34;
    dumpable = {}
    for k, v in self.__dict__.items():
        if isinstance(v, np.ndarray):
            dumpable[k] = [v.tolist(), True]
        elif isinstance(v, np.int32):
            dumpable[k] = [int(v), False]
        else:
            dumpable[k] = [v, False]
    if return_json:
        return json.dumps(dumpable)
    else:
        return dumpable</code></pre>
</details>
</dd>
<dt id="gallop.z_matrix.Z_matrix.zm_angles_to_radians"><code class="name flex">
<span>def <span class="ident">zm_angles_to_radians</span></span>(<span>self, zm)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert angles from degrees to radians</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>zm</code></strong> :&ensp;<code>numpy array</code></dt>
<dd>the Z-matrix coordinates array, shape = n_atoms, 3
where the second and third columns are bond angles and torsions
in degrees.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy array</code></dt>
<dd>Z-matrix coordinates array, shape = n_atoms, 3
where the second and third columns are bond angles and torsions
in radians.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zm_angles_to_radians(self, zm):
    &#34;&#34;&#34;
    Convert angles from degrees to radians

    Args:
        zm (numpy array): the Z-matrix coordinates array, shape = n_atoms, 3
            where the second and third columns are bond angles and torsions
            in degrees.

    Returns:
        numpy array: Z-matrix coordinates array, shape = n_atoms, 3
            where the second and third columns are bond angles and torsions
            in radians.
    &#34;&#34;&#34;
    zm_radians = np.copy(zm)
    zm_radians[:,1] = np.deg2rad(zm_radians[:,1])
    zm_radians[:,2] = np.deg2rad(zm_radians[:,2])
    return zm_radians</code></pre>
</details>
</dd>
<dt id="gallop.z_matrix.Z_matrix.zm_to_cart"><code class="name flex">
<span>def <span class="ident">zm_to_cart</span></span>(<span>self, zm, bond_connection, angle_connection, torsion_connection)</span>
</code></dt>
<dd>
<div class="desc"><p>Uses the Natural Extension Reference Frame method to convert from
Internal to Cartesian coordinates.
Paper here: <a href="https://onlinelibrary.wiley.com/doi/abs/10.1002/jcc.20237">https://onlinelibrary.wiley.com/doi/abs/10.1002/jcc.20237</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zm_to_cart(self,zm,bond_connection,angle_connection,torsion_connection):
    &#34;&#34;&#34;
    Uses the Natural Extension Reference Frame method to convert from
    Internal to Cartesian coordinates.
    Paper here: https://onlinelibrary.wiley.com/doi/abs/10.1002/jcc.20237
    &#34;&#34;&#34;

    def cross_product(a, b):
        &#34;&#34;&#34;
        Performs the cross-product of two three-dimensional vectors.
        &#34;&#34;&#34;
        return np.array([a[1]*b[2] - a[2]*b[1],
                        a[2]*b[0] - a[0]*b[2],
                        a[0]*b[1] - a[1]*b[0]])

    def get_D2(zm):
        &#34;&#34;&#34;
        Produces the D2 matrix described in the NERF paper linked above.
        &#34;&#34;&#34;
        R = zm[:,0]
        c_t = np.cos(zm[:,1])
        s_t = np.sin(zm[:,1])
        c_p = np.cos(zm[:,2])
        s_p = np.sin(zm[:,2])
        D2 = np.empty((zm.shape[0], 3))
        for i in range(D2.shape[0]):
            D2[i] = R[i] * np.array([-c_t[i], c_p[i]*s_t[i], s_p[i]*s_t[i]])
        return D2

    def normalize(vector):
        &#34;&#34;&#34;
        Normalize a vector
        &#34;&#34;&#34;
        return vector / np.sqrt(np.dot(vector, vector))

    D2 = get_D2(zm)
    cart = np.zeros_like(D2)
    cart[0:3] = D2[0:3]
    for i in range(3, zm.shape[0]):
        C = cart[bond_connection[i]]
        B = cart[angle_connection[i]]
        A = cart[torsion_connection[i]]
        bc = normalize(C - B)
        AB = B - A
        n = normalize(cross_product(AB, bc))
        n_bc = cross_product(n, bc)
        M = np.vstack((bc, n_bc, n))
        cart[i] = np.dot(M.T, D2[i]) + C
    return cart</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gallop" href="index.html">gallop</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="gallop.z_matrix.Z_matrix" href="#gallop.z_matrix.Z_matrix">Z_matrix</a></code></h4>
<ul class="">
<li><code><a title="gallop.z_matrix.Z_matrix.from_json" href="#gallop.z_matrix.Z_matrix.from_json">from_json</a></code></li>
<li><code><a title="gallop.z_matrix.Z_matrix.get_degrees_of_freedom" href="#gallop.z_matrix.Z_matrix.get_degrees_of_freedom">get_degrees_of_freedom</a></code></li>
<li><code><a title="gallop.z_matrix.Z_matrix.get_initial_D2_for_torch" href="#gallop.z_matrix.Z_matrix.get_initial_D2_for_torch">get_initial_D2_for_torch</a></code></li>
<li><code><a title="gallop.z_matrix.Z_matrix.read_DASH_zm" href="#gallop.z_matrix.Z_matrix.read_DASH_zm">read_DASH_zm</a></code></li>
<li><code><a title="gallop.z_matrix.Z_matrix.read_Gaussian_zm" href="#gallop.z_matrix.Z_matrix.read_Gaussian_zm">read_Gaussian_zm</a></code></li>
<li><code><a title="gallop.z_matrix.Z_matrix.remove_H_from_zm" href="#gallop.z_matrix.Z_matrix.remove_H_from_zm">remove_H_from_zm</a></code></li>
<li><code><a title="gallop.z_matrix.Z_matrix.to_json" href="#gallop.z_matrix.Z_matrix.to_json">to_json</a></code></li>
<li><code><a title="gallop.z_matrix.Z_matrix.zm_angles_to_radians" href="#gallop.z_matrix.Z_matrix.zm_angles_to_radians">zm_angles_to_radians</a></code></li>
<li><code><a title="gallop.z_matrix.Z_matrix.zm_to_cart" href="#gallop.z_matrix.Z_matrix.zm_to_cart">zm_to_cart</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>