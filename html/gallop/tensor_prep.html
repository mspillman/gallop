<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>gallop.tensor_prep API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gallop.tensor_prep</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import torch
import numpy as np


def get_zm_related_tensors(Structure, n_samples, dtype, device):
    &#34;&#34;&#34;
    Get tensors about the ZMs from the numpy arrays in the Structure.

    The external and internal DoF tensors may contain information
    pertaining to multiple fragments. The information needs to be indexed
    such that positions, rotations and torsions are assigned consistently
    and correctly. Example below has 2 fragments, with 6 torsions each.
    Each fragment therefore requires:
        3 x position, 4 x quaternions, 6 x torsions
    The layout of the DoF of the tensors is as follows:
        external = n_samples*[pos_1_x, pos_1_y, pos_1_z, pos_2_x, pos_2_y,
                                pos_2_z, rot_1_q1, rot_1_q2, rot_1_q3, rot_1_q4,
                                rot_2_q1, rot_2_q2, rot_2_q3, rot_2_q4]
        internal = n_samples*[tor_1_1, tor_1_2, tor_1_3, tor_1_4, tor_1_5,
                                tor_1_6, tor_2_1, tor_2_2, tor_2_3, tor_2_4,
                                tor_2_5, tor_2_6]
    This function makes lists of numpy arrays: position_indices,
    rotation_indices, torsion_indices that denote what information
    pertains to each fragment. In the above example:
        position_indices = [[0,1,2], [3,4,5]]
        rotation_indices = [[6,7,8,9], [10,11,12,13]]
        torsion_indices  = [[0,1,2,3,4,5], [6,7,8,9,10,11]]

    Args:
        Structure (class): GALLOP structure object
        n_samples (int): Number of simultaneous samples to load
        dtype (torch dtype): dtype to use for tensors
        device (torch device): device to move tensors to

    Returns:
        dict: Dictionary of the tensors. The complete dict of values returned
        by this function is given below:
            tensors = {&#34;zmatrices_degrees_of_freedom&#34; : zm_degrees_of_freedom,
                    &#34;position&#34; : zm_position_indices,
                    &#34;rotation&#34; : zm_rotation_indices,
                    &#34;torsion&#34; : zm_torsion_indices,
                    &#34;initial_D2&#34; : init_D2,
                    &#34;torsion_refineable_indices&#34; : torsion_refineable_indices,
                    &#34;bond_connection&#34; : bond_connection,
                    &#34;angle_connection&#34; : angle_connection,
                    &#34;torsion_connection&#34; : torsion_connection,
                    &#34;init_cart_coords&#34; : init_cart_coords,
                    &#34;nsamples_ones&#34; : nsamples_ones
                    }
    &#34;&#34;&#34;
    position_indices = []
    rotation_indices = []
    torsion_indices = []
    zm_degrees_of_freedom = []
    init_D2 = []
    torsion_refineable_indices = []
    bond_connection = []
    angle_connection = []
    torsion_connection = []
    init_cart_coords = []
    n_atoms_asymmetric = 0
    i = 0
    # First loop over each of the z-matrices and get information about
    # connectivity, degrees of freedom etc
    for i, zm in enumerate(Structure.zmatrices):
        # First generate the indices needed
        if i == 0:
            position_indices.append(np.arange(zm.position_degrees_of_freedom))
            rotation_indices.append(np.arange(zm.rotation_degrees_of_freedom))
            torsion_indices.append(np.arange(zm.internal_degrees_of_freedom))
        else:
            try:
                max_pos = np.hstack(position_indices).max()
            except ValueError:
                max_pos = -1
            try:
                max_rot = np.hstack(rotation_indices).max()
            except ValueError:
                max_rot = -1
            try:
                max_tor = np.hstack(torsion_indices).max()
            except ValueError:
                max_tor = -1
            position_indices.append(np.arange(zm.position_degrees_of_freedom)
                                            + max_pos + 1)
            rotation_indices.append(np.arange(zm.rotation_degrees_of_freedom)
                                            + max_rot + 1)
            torsion_indices.append(np.arange(zm.internal_degrees_of_freedom)
                                            + max_tor + 1)
        zm_degrees_of_freedom.append(zm.degrees_of_freedom)

        # Now get initial D2 matrix and torsion refineable indices for
        # internal -&gt; Cartesian conversion
        # and get initial Cartesian coordinates for rigid bodies. See (S)NeRF
        # paper and gallop.z_matrix for more details.
        if Structure.ignore_H_atoms:
            init_D2_stacked = zm.initial_D2_no_H.reshape(1,
                        zm.initial_D2_no_H.shape[0],
                        zm.initial_D2_no_H.shape[1]).repeat(n_samples,axis=0)
            torsion_refineable_indices.append(torch.from_numpy(
                zm.torsion_refineable_indices_no_H).type(torch.long).to(device))
            if zm.degrees_of_freedom == 7:
                init_cart_coords.append(torch.from_numpy(
                        zm.initial_cartesian_no_H.reshape(1,
                        zm.initial_cartesian_no_H.shape[0],
                        zm.initial_cartesian_no_H.shape[1])
                        .repeat(n_samples,axis=0)).type(dtype).to(device))
            else:
                init_cart_coords.append([])
        else:
            init_D2_stacked = zm.initial_D2.reshape(1,
                                zm.initial_D2.shape[0],
                                zm.initial_D2.shape[1]).repeat(n_samples,axis=0)
            torsion_refineable_indices.append(
                torch.from_numpy(
                    zm.torsion_refineable_indices).type(torch.long).to(device)
                )
            if zm.degrees_of_freedom == 7:
                init_cart_coords.append(torch.from_numpy(
                        zm.initial_cartesian.reshape(1,
                            zm.initial_cartesian.shape[0],
                            zm.initial_cartesian.shape[1]).repeat(
                                n_samples,axis=0)).type(dtype).to(device)
                                )
            else:
                init_cart_coords.append([])

        init_D2.append(torch.from_numpy(init_D2_stacked).type(dtype).to(device))

        # Next get the molecular connectivity information
        if Structure.ignore_H_atoms:
            bond_connection.append(
                torch.from_numpy(
                    zm.bond_connection_no_H).type(torch.long).to(device)
                )
            angle_connection.append(
                torch.from_numpy(
                    zm.angle_connection_no_H).type(torch.long).to(device)
                )
            torsion_connection.append(
                torch.from_numpy(
                    zm.torsion_connection_no_H).type(torch.long).to(device)
                )
        else:
            bond_connection.append(
                torch.from_numpy(zm.bond_connection).type(torch.long).to(device)
                )
            angle_connection.append(
                torch.from_numpy(
                    zm.angle_connection).type(torch.long).to(device)
                )
            torsion_connection.append(
                torch.from_numpy(
                    zm.torsion_connection).type(torch.long).to(device)
                )
        if Structure.ignore_H_atoms:
            n_atoms_asymmetric += zm.coords_no_H.shape[0]
        else:
            n_atoms_asymmetric += zm.coords.shape[0]

    # Now correct the external DoF indices for rotations
    # The external input has the following layout:
    # pos_zm_1, pos_zm_2, ... , pos_zm_n, rot_zm_1, rot_zm_2, ... , rot_zm_n
    # so the previously generated indices need to be corrected for the total
    # number of positional indexes that are also included.
    for r in rotation_indices:
        try:
            r+=np.hstack(position_indices).max()+1
        except ValueError:
            pass

    # Add this information to the Structure object for easy access
    Structure.degrees_of_freedom = zm_degrees_of_freedom
    Structure.position_indices   = position_indices
    Structure.rotation_indices   = rotation_indices
    Structure.torsion_indices    = torsion_indices

    # Create the lists of PyTorch tensors needed. Tensors used for indexing must
    # be of type torch.long
    zm_position_indices = []
    zm_rotation_indices = []
    zm_torsion_indices  = []
    for p in position_indices:
        zm_position_indices.append(
                                torch.from_numpy(p).type(torch.long).to(device))
    for r in rotation_indices:
        zm_rotation_indices.append(
                                torch.from_numpy(r).type(torch.long).to(device))
    for t in torsion_indices:
        zm_torsion_indices.append(
                                torch.from_numpy(t).type(torch.long).to(device))

    # nsamples_ones needed for fall-back Structure factor calculation method.
    # It is concatenated with the x,y,z fractional coordinates, which then
    # allows for multiplication with the affine matrices to generate symmetry
    # equivalent positions.
    nsamples_ones = torch.ones(n_samples,
                                n_atoms_asymmetric,
                                1).type(dtype).to(device)

    tensors = {&#34;zmatrices_degrees_of_freedom&#34; : zm_degrees_of_freedom,
                &#34;position&#34; : zm_position_indices,
                &#34;rotation&#34; : zm_rotation_indices,
                &#34;torsion&#34; : zm_torsion_indices,
                &#34;initial_D2&#34; : init_D2,
                &#34;torsion_refineable_indices&#34; : torsion_refineable_indices,
                &#34;bond_connection&#34; : bond_connection,
                &#34;angle_connection&#34; : angle_connection,
                &#34;torsion_connection&#34; : torsion_connection,
                &#34;init_cart_coords&#34; : init_cart_coords,
                &#34;nsamples_ones&#34; : nsamples_ones}

    return tensors

def get_dw_factors(Structure):
    &#34;&#34;&#34;
    Get the Debye-Waller factors for inclusion in the intensity calculations

    Args:
        Structure (class): GALLOP structure object

    Returns:
        dict: Debye-Waller factors for each atom in a ZM.
    &#34;&#34;&#34;
    dw_factors = {}
    for zm in Structure.zmatrices:
        dw_factors.update(zm.dw_factors)
    return dw_factors

def get_data_related_tensors(Structure, n_reflections, dtype, device,
    verbose=True):
    &#34;&#34;&#34;
    Get tensors about the PXRD data from the numpy arrays in the Structure

    Args:
        Structure (class): GALLOP structure object
        n_reflections ([type]): Number of reflections to consider for chi_2
            calculation
        dtype (torch dtype): dtype to use for tensors
        device (torch device): device to move tensors to
        verbose (bool, optional): [description]. Defaults to True.

    Returns:
        dict: Dictionary of the tensors
    &#34;&#34;&#34;
    if n_reflections is not None:
        assert n_reflections &gt; 0, &#34;Cannot optimise with &lt;= 0 reflections&#34;
        if n_reflections &gt;  len(Structure.hkl):
            n_reflections = len(Structure.hkl)
    else:
        n_reflections = len(Structure.hkl)
    if verbose:
        total_ref = len(Structure.hkl)
        res = Structure.get_resolution(Structure.twotheta[n_reflections-1], )
        print(&#34;Using&#34;,n_reflections,&#34;of&#34;,total_ref,&#34;available reflections.&#34;)
        print(&#34;Resolution with&#34;,n_reflections,&#34;reflections:&#34;,res)

    tensors = {}
    tensors[&#34;affine_matrices&#34;] = torch.from_numpy(
                        Structure.affine_matrices).type(dtype).to(device)
    tensors[&#34;hkl&#34;] = torch.from_numpy(
                        Structure.hkl[:n_reflections].T).type(dtype).to(device)
    tensors[&#34;lattice_inv_matrix&#34;] = torch.from_numpy(
                np.copy(Structure.lattice.inv_matrix)).type(dtype).to(device)


    inverse_covariance_matrix = Structure.inverse_covariance_matrix
    inverse_covariance_matrix = inverse_covariance_matrix[:n_reflections,
                                                            :n_reflections]
    tensors[&#34;inverse_covariance_matrix&#34;] = torch.from_numpy(
                            inverse_covariance_matrix).type(dtype).to(device)
    tensors[&#34;observed_intensities&#34;] = torch.from_numpy(
                Structure.intensities[:n_reflections]).type(dtype).to(device)
    tensors[&#34;chisqd_scale_sum_1_1&#34;] = torch.mv(
        tensors[&#34;inverse_covariance_matrix&#34;], tensors[&#34;observed_intensities&#34;])
    return tensors

def get_all_required_tensors(Structure, external=None, internal=None,
    n_samples=10000, device=None, dtype=None, n_reflections=None, verbose=True,
    include_dw_factors=True, requires_grad=True, from_CIF=False):
    &#34;&#34;&#34;
    Gather all of the information needed to run calculations on the GPU. This
    will differ depending on if the input is a set of external/internal degrees
    of freedom (standard) or if the input is directly from a CIF (used for
    mostly for debugging and comparison to DASH-derived values)

    Args:
        Structure (Structure Class): Class containing all of the data and
            z-matrices
        external (Numpy array, optional): Either a numpy array of the external
            DoF or None.
            If None, then the external DoF will be generated randomly.
            Defaults to None.
        internal (Numpy array, optional): Either a numpy array of the internal
            DoF or None.
            If None, then the external DoF will be generated randomly.
            Defaults to None.
        n_samples (int, optional): If external is None, sets how many samples
            of external DoF to take. Defaults to 10000.
        device (torch device, optional): Where to run the code. If None, will
            check for a GPU and run on that if one is available.
        n_reflections (int, optional): Number of reflections to consider in
            chi^2 calculations. If None, will use all available.
        verbose (bool, optional): Print out some information or not. Defaults
            to True.
        include_dw_factors (bool, optional): Include Debye-Waller factors in
            the intensity calculations. Defaults to True.
        requires_grad (bool, optional): Gradients are required if parameters
            (external, internal) need to be optimised. Defaults to True.
        from_CIF (bool, optional): If reading coordinates from a CIF, need to
            change which tensors are required. Defaults to False.

    Returns:
        dict: A dictionary of the required Tensors
    &#34;&#34;&#34;
    if len(Structure.zmatrices) == 0:
        print(&#34;Error - no Z-matrices have been added to the Structure&#34;)
        return None
    else:
        if not hasattr(Structure, &#34;total_internal_degrees_of_freedom&#34;):
            Structure.get_total_degrees_of_freedom()

    if device is None:
        device = torch.device(&#39;cuda&#39; if torch.cuda.is_available() else &#39;cpu&#39;)
    if dtype is None:
        dtype = torch.float32

    if external is None:
        pos = torch.rand(
                    (n_samples, Structure.total_position_degrees_of_freedom))
        rot = torch.rand(
                    (n_samples, Structure.total_rotation_degrees_of_freedom))
        rot -= 0.5
        rot *= 2
        external = torch.cat([pos, rot], dim=1)
        external = external.type(dtype).to(device)
        if requires_grad:
            external.requires_grad = True
    else:
        n_samples = external.shape[0]
        try:
            external = torch.from_numpy(external).type(dtype).to(device)
            if requires_grad:
                external.requires_grad = True
        except TypeError:
            print(&#34;Can&#39;t convert input&#34;,external,&#34;to pytorch tensor&#34;)

    if internal is None:
        tor = torch.rand((n_samples,
                        Structure.total_internal_degrees_of_freedom))
        tor -= 0.5
        tor *= 2*np.pi
        internal = tor.type(dtype).to(device)
        if requires_grad:
            internal.requires_grad = True
    else:
        error = &#34;external.shape[0] != internal.shape[0]&#34;
        assert n_samples == internal.shape[0], error
        try:
            internal = torch.from_numpy(internal).type(dtype).to(device)
            if requires_grad:
                internal.requires_grad = True
        except TypeError:
            print(&#34;Can&#39;t convert input&#34;,internal,&#34;to pytorch tensor&#34;)

    if include_dw_factors:
        if from_CIF:
            dw_factors = Structure.CIF_dw_factors
        else:
            dw_factors = get_dw_factors(Structure)
    else:
        dw_factors = {}

    tensors =  {&#34;external&#34; : external,
                &#34;internal&#34; : internal,
                **get_data_related_tensors(Structure, n_reflections,
                                    dtype, device, verbose=verbose)
                }
    if from_CIF:
        if Structure.ignore_H_atoms:
            n_atoms_asymmetric = Structure.cif_frac_coords_no_H.shape[0]
            asymmetric_frac_coords = Structure.cif_frac_coords_no_H.reshape(1,
                                                        n_atoms_asymmetric,3)
        else:
            n_atoms_asymmetric = Structure.cif_frac_coords.shape[0]
            asymmetric_frac_coords = Structure.cif_frac_coords.reshape(1,
                                                        n_atoms_asymmetric,3)
        asymmetric_frac_coords = torch.from_numpy(asymmetric_frac_coords)
        asymmetric_frac_coords = asymmetric_frac_coords.type(dtype).to(device)
        nsamples_ones = torch.ones(n_samples,
                                n_atoms_asymmetric,
                                1).type(dtype).to(device)
        tensors = {
            **tensors,
            &#34;asymmetric_frac_coords&#34; : asymmetric_frac_coords,
            &#34;nsamples_ones&#34; : nsamples_ones,
        }
    else:
        tensors = {**tensors, **get_zm_related_tensors(Structure,
                                                    n_samples, dtype, device)}
    # Calculate terms that are used in the intensity calculations, which include
    # the atomic scattering factors etc.
    full_prefix = Structure.generate_intensity_calculation_prefix(
                        debye_waller_factors=dw_factors, just_asymmetric=False,
                        from_cif=from_CIF)[:n_reflections]
    asymm_prefix = Structure.generate_intensity_calculation_prefix(
                        debye_waller_factors=dw_factors, just_asymmetric=True,
                        from_cif=from_CIF)[:n_reflections]

    tensors[&#34;intensity_calc_prefix_fs&#34;] = torch.from_numpy(
                                            full_prefix).type(dtype).to(device)
    tensors[&#34;intensity_calc_prefix_fs_asymmetric&#34;] = torch.from_numpy(
                                            asymm_prefix).type(dtype).to(device)
    tensors[&#34;centrosymmetric&#34;] = Structure.centrosymmetric
    tensors[&#34;space_group_number&#34;] = Structure.sg_number
    return tensors</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gallop.tensor_prep.get_all_required_tensors"><code class="name flex">
<span>def <span class="ident">get_all_required_tensors</span></span>(<span>Structure, external=None, internal=None, n_samples=10000, device=None, dtype=None, n_reflections=None, verbose=True, include_dw_factors=True, requires_grad=True, from_CIF=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Gather all of the information needed to run calculations on the GPU. This
will differ depending on if the input is a set of external/internal degrees
of freedom (standard) or if the input is directly from a CIF (used for
mostly for debugging and comparison to DASH-derived values)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>Structure</code></strong> :&ensp;<code>Structure Class</code></dt>
<dd>Class containing all of the data and
z-matrices</dd>
<dt><strong><code>external</code></strong> :&ensp;<code>Numpy array</code>, optional</dt>
<dd>Either a numpy array of the external
DoF or None.
If None, then the external DoF will be generated randomly.
Defaults to None.</dd>
<dt><strong><code>internal</code></strong> :&ensp;<code>Numpy array</code>, optional</dt>
<dd>Either a numpy array of the internal
DoF or None.
If None, then the external DoF will be generated randomly.
Defaults to None.</dd>
<dt><strong><code>n_samples</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>If external is None, sets how many samples
of external DoF to take. Defaults to 10000.</dd>
<dt><strong><code>device</code></strong> :&ensp;<code>torch device</code>, optional</dt>
<dd>Where to run the code. If None, will
check for a GPU and run on that if one is available.</dd>
<dt><strong><code>n_reflections</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of reflections to consider in
chi^2 calculations. If None, will use all available.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Print out some information or not. Defaults
to True.</dd>
<dt><strong><code>include_dw_factors</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Include Debye-Waller factors in
the intensity calculations. Defaults to True.</dd>
<dt><strong><code>requires_grad</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Gradients are required if parameters
(external, internal) need to be optimised. Defaults to True.</dd>
<dt><strong><code>from_CIF</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If reading coordinates from a CIF, need to
change which tensors are required. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary of the required Tensors</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_required_tensors(Structure, external=None, internal=None,
    n_samples=10000, device=None, dtype=None, n_reflections=None, verbose=True,
    include_dw_factors=True, requires_grad=True, from_CIF=False):
    &#34;&#34;&#34;
    Gather all of the information needed to run calculations on the GPU. This
    will differ depending on if the input is a set of external/internal degrees
    of freedom (standard) or if the input is directly from a CIF (used for
    mostly for debugging and comparison to DASH-derived values)

    Args:
        Structure (Structure Class): Class containing all of the data and
            z-matrices
        external (Numpy array, optional): Either a numpy array of the external
            DoF or None.
            If None, then the external DoF will be generated randomly.
            Defaults to None.
        internal (Numpy array, optional): Either a numpy array of the internal
            DoF or None.
            If None, then the external DoF will be generated randomly.
            Defaults to None.
        n_samples (int, optional): If external is None, sets how many samples
            of external DoF to take. Defaults to 10000.
        device (torch device, optional): Where to run the code. If None, will
            check for a GPU and run on that if one is available.
        n_reflections (int, optional): Number of reflections to consider in
            chi^2 calculations. If None, will use all available.
        verbose (bool, optional): Print out some information or not. Defaults
            to True.
        include_dw_factors (bool, optional): Include Debye-Waller factors in
            the intensity calculations. Defaults to True.
        requires_grad (bool, optional): Gradients are required if parameters
            (external, internal) need to be optimised. Defaults to True.
        from_CIF (bool, optional): If reading coordinates from a CIF, need to
            change which tensors are required. Defaults to False.

    Returns:
        dict: A dictionary of the required Tensors
    &#34;&#34;&#34;
    if len(Structure.zmatrices) == 0:
        print(&#34;Error - no Z-matrices have been added to the Structure&#34;)
        return None
    else:
        if not hasattr(Structure, &#34;total_internal_degrees_of_freedom&#34;):
            Structure.get_total_degrees_of_freedom()

    if device is None:
        device = torch.device(&#39;cuda&#39; if torch.cuda.is_available() else &#39;cpu&#39;)
    if dtype is None:
        dtype = torch.float32

    if external is None:
        pos = torch.rand(
                    (n_samples, Structure.total_position_degrees_of_freedom))
        rot = torch.rand(
                    (n_samples, Structure.total_rotation_degrees_of_freedom))
        rot -= 0.5
        rot *= 2
        external = torch.cat([pos, rot], dim=1)
        external = external.type(dtype).to(device)
        if requires_grad:
            external.requires_grad = True
    else:
        n_samples = external.shape[0]
        try:
            external = torch.from_numpy(external).type(dtype).to(device)
            if requires_grad:
                external.requires_grad = True
        except TypeError:
            print(&#34;Can&#39;t convert input&#34;,external,&#34;to pytorch tensor&#34;)

    if internal is None:
        tor = torch.rand((n_samples,
                        Structure.total_internal_degrees_of_freedom))
        tor -= 0.5
        tor *= 2*np.pi
        internal = tor.type(dtype).to(device)
        if requires_grad:
            internal.requires_grad = True
    else:
        error = &#34;external.shape[0] != internal.shape[0]&#34;
        assert n_samples == internal.shape[0], error
        try:
            internal = torch.from_numpy(internal).type(dtype).to(device)
            if requires_grad:
                internal.requires_grad = True
        except TypeError:
            print(&#34;Can&#39;t convert input&#34;,internal,&#34;to pytorch tensor&#34;)

    if include_dw_factors:
        if from_CIF:
            dw_factors = Structure.CIF_dw_factors
        else:
            dw_factors = get_dw_factors(Structure)
    else:
        dw_factors = {}

    tensors =  {&#34;external&#34; : external,
                &#34;internal&#34; : internal,
                **get_data_related_tensors(Structure, n_reflections,
                                    dtype, device, verbose=verbose)
                }
    if from_CIF:
        if Structure.ignore_H_atoms:
            n_atoms_asymmetric = Structure.cif_frac_coords_no_H.shape[0]
            asymmetric_frac_coords = Structure.cif_frac_coords_no_H.reshape(1,
                                                        n_atoms_asymmetric,3)
        else:
            n_atoms_asymmetric = Structure.cif_frac_coords.shape[0]
            asymmetric_frac_coords = Structure.cif_frac_coords.reshape(1,
                                                        n_atoms_asymmetric,3)
        asymmetric_frac_coords = torch.from_numpy(asymmetric_frac_coords)
        asymmetric_frac_coords = asymmetric_frac_coords.type(dtype).to(device)
        nsamples_ones = torch.ones(n_samples,
                                n_atoms_asymmetric,
                                1).type(dtype).to(device)
        tensors = {
            **tensors,
            &#34;asymmetric_frac_coords&#34; : asymmetric_frac_coords,
            &#34;nsamples_ones&#34; : nsamples_ones,
        }
    else:
        tensors = {**tensors, **get_zm_related_tensors(Structure,
                                                    n_samples, dtype, device)}
    # Calculate terms that are used in the intensity calculations, which include
    # the atomic scattering factors etc.
    full_prefix = Structure.generate_intensity_calculation_prefix(
                        debye_waller_factors=dw_factors, just_asymmetric=False,
                        from_cif=from_CIF)[:n_reflections]
    asymm_prefix = Structure.generate_intensity_calculation_prefix(
                        debye_waller_factors=dw_factors, just_asymmetric=True,
                        from_cif=from_CIF)[:n_reflections]

    tensors[&#34;intensity_calc_prefix_fs&#34;] = torch.from_numpy(
                                            full_prefix).type(dtype).to(device)
    tensors[&#34;intensity_calc_prefix_fs_asymmetric&#34;] = torch.from_numpy(
                                            asymm_prefix).type(dtype).to(device)
    tensors[&#34;centrosymmetric&#34;] = Structure.centrosymmetric
    tensors[&#34;space_group_number&#34;] = Structure.sg_number
    return tensors</code></pre>
</details>
</dd>
<dt id="gallop.tensor_prep.get_data_related_tensors"><code class="name flex">
<span>def <span class="ident">get_data_related_tensors</span></span>(<span>Structure, n_reflections, dtype, device, verbose=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Get tensors about the PXRD data from the numpy arrays in the Structure</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>Structure</code></strong> :&ensp;<code>class</code></dt>
<dd>GALLOP structure object</dd>
<dt><strong><code>n_reflections</code></strong> :&ensp;<code>[type]</code></dt>
<dd>Number of reflections to consider for chi_2
calculation</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>torch dtype</code></dt>
<dd>dtype to use for tensors</dd>
<dt><strong><code>device</code></strong> :&ensp;<code>torch device</code></dt>
<dd>device to move tensors to</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>[description]. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Dictionary of the tensors</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_data_related_tensors(Structure, n_reflections, dtype, device,
    verbose=True):
    &#34;&#34;&#34;
    Get tensors about the PXRD data from the numpy arrays in the Structure

    Args:
        Structure (class): GALLOP structure object
        n_reflections ([type]): Number of reflections to consider for chi_2
            calculation
        dtype (torch dtype): dtype to use for tensors
        device (torch device): device to move tensors to
        verbose (bool, optional): [description]. Defaults to True.

    Returns:
        dict: Dictionary of the tensors
    &#34;&#34;&#34;
    if n_reflections is not None:
        assert n_reflections &gt; 0, &#34;Cannot optimise with &lt;= 0 reflections&#34;
        if n_reflections &gt;  len(Structure.hkl):
            n_reflections = len(Structure.hkl)
    else:
        n_reflections = len(Structure.hkl)
    if verbose:
        total_ref = len(Structure.hkl)
        res = Structure.get_resolution(Structure.twotheta[n_reflections-1], )
        print(&#34;Using&#34;,n_reflections,&#34;of&#34;,total_ref,&#34;available reflections.&#34;)
        print(&#34;Resolution with&#34;,n_reflections,&#34;reflections:&#34;,res)

    tensors = {}
    tensors[&#34;affine_matrices&#34;] = torch.from_numpy(
                        Structure.affine_matrices).type(dtype).to(device)
    tensors[&#34;hkl&#34;] = torch.from_numpy(
                        Structure.hkl[:n_reflections].T).type(dtype).to(device)
    tensors[&#34;lattice_inv_matrix&#34;] = torch.from_numpy(
                np.copy(Structure.lattice.inv_matrix)).type(dtype).to(device)


    inverse_covariance_matrix = Structure.inverse_covariance_matrix
    inverse_covariance_matrix = inverse_covariance_matrix[:n_reflections,
                                                            :n_reflections]
    tensors[&#34;inverse_covariance_matrix&#34;] = torch.from_numpy(
                            inverse_covariance_matrix).type(dtype).to(device)
    tensors[&#34;observed_intensities&#34;] = torch.from_numpy(
                Structure.intensities[:n_reflections]).type(dtype).to(device)
    tensors[&#34;chisqd_scale_sum_1_1&#34;] = torch.mv(
        tensors[&#34;inverse_covariance_matrix&#34;], tensors[&#34;observed_intensities&#34;])
    return tensors</code></pre>
</details>
</dd>
<dt id="gallop.tensor_prep.get_dw_factors"><code class="name flex">
<span>def <span class="ident">get_dw_factors</span></span>(<span>Structure)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the Debye-Waller factors for inclusion in the intensity calculations</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>Structure</code></strong> :&ensp;<code>class</code></dt>
<dd>GALLOP structure object</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Debye-Waller factors for each atom in a ZM.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_dw_factors(Structure):
    &#34;&#34;&#34;
    Get the Debye-Waller factors for inclusion in the intensity calculations

    Args:
        Structure (class): GALLOP structure object

    Returns:
        dict: Debye-Waller factors for each atom in a ZM.
    &#34;&#34;&#34;
    dw_factors = {}
    for zm in Structure.zmatrices:
        dw_factors.update(zm.dw_factors)
    return dw_factors</code></pre>
</details>
</dd>
<dt id="gallop.tensor_prep.get_zm_related_tensors"><code class="name flex">
<span>def <span class="ident">get_zm_related_tensors</span></span>(<span>Structure, n_samples, dtype, device)</span>
</code></dt>
<dd>
<div class="desc"><p>Get tensors about the ZMs from the numpy arrays in the Structure.</p>
<p>The external and internal DoF tensors may contain information
pertaining to multiple fragments. The information needs to be indexed
such that positions, rotations and torsions are assigned consistently
and correctly. Example below has 2 fragments, with 6 torsions each.
Each fragment therefore requires:
3 x position, 4 x quaternions, 6 x torsions
The layout of the DoF of the tensors is as follows:
external = n_samples<em>[pos_1_x, pos_1_y, pos_1_z, pos_2_x, pos_2_y,
pos_2_z, rot_1_q1, rot_1_q2, rot_1_q3, rot_1_q4,
rot_2_q1, rot_2_q2, rot_2_q3, rot_2_q4]
internal = n_samples</em>[tor_1_1, tor_1_2, tor_1_3, tor_1_4, tor_1_5,
tor_1_6, tor_2_1, tor_2_2, tor_2_3, tor_2_4,
tor_2_5, tor_2_6]
This function makes lists of numpy arrays: position_indices,
rotation_indices, torsion_indices that denote what information
pertains to each fragment. In the above example:
position_indices = [[0,1,2], [3,4,5]]
rotation_indices = [[6,7,8,9], [10,11,12,13]]
torsion_indices
= [[0,1,2,3,4,5], [6,7,8,9,10,11]]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>Structure</code></strong> :&ensp;<code>class</code></dt>
<dd>GALLOP structure object</dd>
<dt><strong><code>n_samples</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of simultaneous samples to load</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>torch dtype</code></dt>
<dd>dtype to use for tensors</dd>
<dt><strong><code>device</code></strong> :&ensp;<code>torch device</code></dt>
<dd>device to move tensors to</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Dictionary of the tensors. The complete dict of values returned</dd>
</dl>
<p>by this function is given below:
tensors = {"zmatrices_degrees_of_freedom" : zm_degrees_of_freedom,
"position" : zm_position_indices,
"rotation" : zm_rotation_indices,
"torsion" : zm_torsion_indices,
"initial_D2" : init_D2,
"torsion_refineable_indices" : torsion_refineable_indices,
"bond_connection" : bond_connection,
"angle_connection" : angle_connection,
"torsion_connection" : torsion_connection,
"init_cart_coords" : init_cart_coords,
"nsamples_ones" : nsamples_ones
}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_zm_related_tensors(Structure, n_samples, dtype, device):
    &#34;&#34;&#34;
    Get tensors about the ZMs from the numpy arrays in the Structure.

    The external and internal DoF tensors may contain information
    pertaining to multiple fragments. The information needs to be indexed
    such that positions, rotations and torsions are assigned consistently
    and correctly. Example below has 2 fragments, with 6 torsions each.
    Each fragment therefore requires:
        3 x position, 4 x quaternions, 6 x torsions
    The layout of the DoF of the tensors is as follows:
        external = n_samples*[pos_1_x, pos_1_y, pos_1_z, pos_2_x, pos_2_y,
                                pos_2_z, rot_1_q1, rot_1_q2, rot_1_q3, rot_1_q4,
                                rot_2_q1, rot_2_q2, rot_2_q3, rot_2_q4]
        internal = n_samples*[tor_1_1, tor_1_2, tor_1_3, tor_1_4, tor_1_5,
                                tor_1_6, tor_2_1, tor_2_2, tor_2_3, tor_2_4,
                                tor_2_5, tor_2_6]
    This function makes lists of numpy arrays: position_indices,
    rotation_indices, torsion_indices that denote what information
    pertains to each fragment. In the above example:
        position_indices = [[0,1,2], [3,4,5]]
        rotation_indices = [[6,7,8,9], [10,11,12,13]]
        torsion_indices  = [[0,1,2,3,4,5], [6,7,8,9,10,11]]

    Args:
        Structure (class): GALLOP structure object
        n_samples (int): Number of simultaneous samples to load
        dtype (torch dtype): dtype to use for tensors
        device (torch device): device to move tensors to

    Returns:
        dict: Dictionary of the tensors. The complete dict of values returned
        by this function is given below:
            tensors = {&#34;zmatrices_degrees_of_freedom&#34; : zm_degrees_of_freedom,
                    &#34;position&#34; : zm_position_indices,
                    &#34;rotation&#34; : zm_rotation_indices,
                    &#34;torsion&#34; : zm_torsion_indices,
                    &#34;initial_D2&#34; : init_D2,
                    &#34;torsion_refineable_indices&#34; : torsion_refineable_indices,
                    &#34;bond_connection&#34; : bond_connection,
                    &#34;angle_connection&#34; : angle_connection,
                    &#34;torsion_connection&#34; : torsion_connection,
                    &#34;init_cart_coords&#34; : init_cart_coords,
                    &#34;nsamples_ones&#34; : nsamples_ones
                    }
    &#34;&#34;&#34;
    position_indices = []
    rotation_indices = []
    torsion_indices = []
    zm_degrees_of_freedom = []
    init_D2 = []
    torsion_refineable_indices = []
    bond_connection = []
    angle_connection = []
    torsion_connection = []
    init_cart_coords = []
    n_atoms_asymmetric = 0
    i = 0
    # First loop over each of the z-matrices and get information about
    # connectivity, degrees of freedom etc
    for i, zm in enumerate(Structure.zmatrices):
        # First generate the indices needed
        if i == 0:
            position_indices.append(np.arange(zm.position_degrees_of_freedom))
            rotation_indices.append(np.arange(zm.rotation_degrees_of_freedom))
            torsion_indices.append(np.arange(zm.internal_degrees_of_freedom))
        else:
            try:
                max_pos = np.hstack(position_indices).max()
            except ValueError:
                max_pos = -1
            try:
                max_rot = np.hstack(rotation_indices).max()
            except ValueError:
                max_rot = -1
            try:
                max_tor = np.hstack(torsion_indices).max()
            except ValueError:
                max_tor = -1
            position_indices.append(np.arange(zm.position_degrees_of_freedom)
                                            + max_pos + 1)
            rotation_indices.append(np.arange(zm.rotation_degrees_of_freedom)
                                            + max_rot + 1)
            torsion_indices.append(np.arange(zm.internal_degrees_of_freedom)
                                            + max_tor + 1)
        zm_degrees_of_freedom.append(zm.degrees_of_freedom)

        # Now get initial D2 matrix and torsion refineable indices for
        # internal -&gt; Cartesian conversion
        # and get initial Cartesian coordinates for rigid bodies. See (S)NeRF
        # paper and gallop.z_matrix for more details.
        if Structure.ignore_H_atoms:
            init_D2_stacked = zm.initial_D2_no_H.reshape(1,
                        zm.initial_D2_no_H.shape[0],
                        zm.initial_D2_no_H.shape[1]).repeat(n_samples,axis=0)
            torsion_refineable_indices.append(torch.from_numpy(
                zm.torsion_refineable_indices_no_H).type(torch.long).to(device))
            if zm.degrees_of_freedom == 7:
                init_cart_coords.append(torch.from_numpy(
                        zm.initial_cartesian_no_H.reshape(1,
                        zm.initial_cartesian_no_H.shape[0],
                        zm.initial_cartesian_no_H.shape[1])
                        .repeat(n_samples,axis=0)).type(dtype).to(device))
            else:
                init_cart_coords.append([])
        else:
            init_D2_stacked = zm.initial_D2.reshape(1,
                                zm.initial_D2.shape[0],
                                zm.initial_D2.shape[1]).repeat(n_samples,axis=0)
            torsion_refineable_indices.append(
                torch.from_numpy(
                    zm.torsion_refineable_indices).type(torch.long).to(device)
                )
            if zm.degrees_of_freedom == 7:
                init_cart_coords.append(torch.from_numpy(
                        zm.initial_cartesian.reshape(1,
                            zm.initial_cartesian.shape[0],
                            zm.initial_cartesian.shape[1]).repeat(
                                n_samples,axis=0)).type(dtype).to(device)
                                )
            else:
                init_cart_coords.append([])

        init_D2.append(torch.from_numpy(init_D2_stacked).type(dtype).to(device))

        # Next get the molecular connectivity information
        if Structure.ignore_H_atoms:
            bond_connection.append(
                torch.from_numpy(
                    zm.bond_connection_no_H).type(torch.long).to(device)
                )
            angle_connection.append(
                torch.from_numpy(
                    zm.angle_connection_no_H).type(torch.long).to(device)
                )
            torsion_connection.append(
                torch.from_numpy(
                    zm.torsion_connection_no_H).type(torch.long).to(device)
                )
        else:
            bond_connection.append(
                torch.from_numpy(zm.bond_connection).type(torch.long).to(device)
                )
            angle_connection.append(
                torch.from_numpy(
                    zm.angle_connection).type(torch.long).to(device)
                )
            torsion_connection.append(
                torch.from_numpy(
                    zm.torsion_connection).type(torch.long).to(device)
                )
        if Structure.ignore_H_atoms:
            n_atoms_asymmetric += zm.coords_no_H.shape[0]
        else:
            n_atoms_asymmetric += zm.coords.shape[0]

    # Now correct the external DoF indices for rotations
    # The external input has the following layout:
    # pos_zm_1, pos_zm_2, ... , pos_zm_n, rot_zm_1, rot_zm_2, ... , rot_zm_n
    # so the previously generated indices need to be corrected for the total
    # number of positional indexes that are also included.
    for r in rotation_indices:
        try:
            r+=np.hstack(position_indices).max()+1
        except ValueError:
            pass

    # Add this information to the Structure object for easy access
    Structure.degrees_of_freedom = zm_degrees_of_freedom
    Structure.position_indices   = position_indices
    Structure.rotation_indices   = rotation_indices
    Structure.torsion_indices    = torsion_indices

    # Create the lists of PyTorch tensors needed. Tensors used for indexing must
    # be of type torch.long
    zm_position_indices = []
    zm_rotation_indices = []
    zm_torsion_indices  = []
    for p in position_indices:
        zm_position_indices.append(
                                torch.from_numpy(p).type(torch.long).to(device))
    for r in rotation_indices:
        zm_rotation_indices.append(
                                torch.from_numpy(r).type(torch.long).to(device))
    for t in torsion_indices:
        zm_torsion_indices.append(
                                torch.from_numpy(t).type(torch.long).to(device))

    # nsamples_ones needed for fall-back Structure factor calculation method.
    # It is concatenated with the x,y,z fractional coordinates, which then
    # allows for multiplication with the affine matrices to generate symmetry
    # equivalent positions.
    nsamples_ones = torch.ones(n_samples,
                                n_atoms_asymmetric,
                                1).type(dtype).to(device)

    tensors = {&#34;zmatrices_degrees_of_freedom&#34; : zm_degrees_of_freedom,
                &#34;position&#34; : zm_position_indices,
                &#34;rotation&#34; : zm_rotation_indices,
                &#34;torsion&#34; : zm_torsion_indices,
                &#34;initial_D2&#34; : init_D2,
                &#34;torsion_refineable_indices&#34; : torsion_refineable_indices,
                &#34;bond_connection&#34; : bond_connection,
                &#34;angle_connection&#34; : angle_connection,
                &#34;torsion_connection&#34; : torsion_connection,
                &#34;init_cart_coords&#34; : init_cart_coords,
                &#34;nsamples_ones&#34; : nsamples_ones}

    return tensors</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gallop" href="index.html">gallop</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="gallop.tensor_prep.get_all_required_tensors" href="#gallop.tensor_prep.get_all_required_tensors">get_all_required_tensors</a></code></li>
<li><code><a title="gallop.tensor_prep.get_data_related_tensors" href="#gallop.tensor_prep.get_data_related_tensors">get_data_related_tensors</a></code></li>
<li><code><a title="gallop.tensor_prep.get_dw_factors" href="#gallop.tensor_prep.get_dw_factors">get_dw_factors</a></code></li>
<li><code><a title="gallop.tensor_prep.get_zm_related_tensors" href="#gallop.tensor_prep.get_zm_related_tensors">get_zm_related_tensors</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>